<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Eternal Brothers FC</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
<style>
body {
  font-family: "Cairo", sans-serif;
  background-color: #121212;
  color: #e0e0e0;
  margin:0;
  padding:10px;
  text-align:center;
}
/* New structure for nav and controls */
.nav-controls {
  margin-bottom: 20px;
  display: flex;
  flex-direction: column; 
  align-items: center; 
}
.nav-buttons-top {
  display: flex;
  /* Original LTR order: Blue (left) - Home (center) - Yellow (right) */
  flex-direction: row; 
  justify-content: space-between;
  width: 100%; 
  max-width: 400px; 
  margin-bottom: 5px; 
}
.nav-buttons-bottom {
  display: flex;
  justify-content: center; 
  width: 100%;
  max-width: 400px;
}
button {
  padding:10px 16px;
  border:none;
  border-radius:8px;
  cursor:pointer;
  font-weight:700;
}
#homeBtn, #blueBtn, #yellowBtn {
    width: 100%; 
    margin: 0 5px; 
}
#homeBtn { background:#d32f2f; color:#fff; }
#blueBtn { background:#1976d2; color:#fff; }
#yellowBtn { background:#fbc02d; color:#000; }
#audioToggleBtn { 
  background: #616161 !important;
  color: #fff !important;
  font-size: 16px;
  padding: 8px 12px;
  width: 100px; 
  margin: 0; 
  border-radius: 8px; 
}

.container {
  display:none;
  max-width:95%;
  margin:auto;
  background:#1e1e1ecc;
  padding:20px 10px;
  border-radius:15px;
  box-shadow:0 0 10px #000;
}
h1,h2,h3 { margin:10px 0; }
/* Reverting input alignment to center/default */
input[type=text] { 
    padding:8px; 
    width:80%; 
    border-radius:8px; 
    border:1px solid #555; 
    margin:5px 0; 
    background:#2c2c2c; 
    color:#fff; 
    text-align:center; 
}
ul { 
    list-style:none; 
    padding:0; 
    margin-top:10px; 
    text-align:left; /* Reverted to LTR alignment */
    font-weight:bold; 
}
li { 
    margin:5px 0; 
    padding:6px; 
    border-radius:8px; 
    display:flex; 
    justify-content:space-between; 
    align-items:center;
    flex-direction: row; /* Reverted to LTR order */
    /* Ensure list items are large enough to hold the time */
    min-height: 40px; 
}
#teamList li { background:#a8e6a1; color:black; }
#waitingList li { background:#ffe0e0; color:black; }
#blueList li { background:rgba(25,118,210,0.7); color:black; }
#yellowList li { background:rgba(251,192,42,0.7); color:#000; }

.player-info {
    /* Changed to flex row to ensure name and time are on the same line */
    display: flex;
    flex-direction: row; 
    align-items: center; /* Vertically center content */
    font-size: 16px;
    font-weight: bold;
}
.player-time {
    font-size: 12px;
    font-weight: normal;
    color: #616161; /* Darker color for time */
    margin-left: 5px; /* Add space after name */
}

.action-btn {
  margin-left:6px;
  border:none;
  border-radius:5px;
  padding:4px 8px;
  cursor:pointer;
  font-weight:bold;
}
.edit-btn { background:#4caf50; color:#fff; }
.delete-btn { background:#e53935; color:#fff; }

.player-marker { 
  width:35px; 
  height:35px; 
  border-radius:50%; 
  color:#fff; 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  font-size:14px; 
  font-weight:bold; 
  position:absolute; 
  cursor:grab; 
  user-select:none; 
}
.player-name {
  position: absolute;
  top: -18px;
  /* Reverting to LTR positioning */
  left: 50%;
  transform: translateX(-50%);
  font-size: 12px;
  color: black;
  white-space: nowrap;
  font-weight: bold;
}

.field { width:100%; max-width:400px; height:250px; background:#4CAF50; margin:10px auto; border:2px solid #fff; border-radius:10px; position:relative; touch-action:none; }
.field .center-circle { position:absolute; width:50px;height:50px;border-radius:50%;border:2px solid #fff; top:50%; left:50%; transform:translate(-50%,-50%); }
.field .penalty-box-left, .field .penalty-box-right { position:absolute;width:60px;height:120px;border:2px solid #fff; top:50%; transform:translateY(-50%); }
.field .penalty-box-left { left:0; }
.field .penalty-box-right { right:0; }
.field .mid-line { position:absolute; width:0;height:100%;border-left:2px solid #fff; top:0; left:50%; transform:translateX(-50%); }

.formation-controls button {
    margin: 5px 3px;
    background: #009688; /* Teal color for formation buttons */
    color: #fff;
    padding: 8px 12px;
    font-size: 14px;
}

/* New style for the dynamic button to make it stand out */
.formation-controls .dynamic-btn {
    background: #FF9800; /* Orange */
    font-weight: 700;
}

/* CHAT STYLES LTR */
.chat-container {
  width: 100%; 
  max-width: 100%; 
  margin: 20px 0 0 0;
  background: #242424;
  border-radius: 10px;
  padding: 10px;
  box-shadow: 0 0 5px #000;
  text-align: left; /* Reverted to LTR */
}
.team-chat-container {
  background: none; /* Inherit background from parent .container */
  box-shadow: none;
  margin: 5px 0 0 0;
  padding: 0;
}

.chat-messages {
  height: 250px;
  overflow-y: auto;
  margin-bottom: 10px;
  padding: 5px;
  background: #1e1e1e;
  border-radius: 5px;
  display: flex;
  flex-direction: column;
  text-align: left; /* Reverted to LTR */
}

/* Specific background for team chats */
#blueChatMessages {
    background: rgba(25, 118, 210, 0.1); /* Lighter blue */
}
#yellowChatMessages {
    background: rgba(251, 192, 42, 0.1); /* Lighter yellow */
}

.message {
  margin-bottom: 8px;
  padding: 8px;
  border-radius: 10px;
  background: #333; 
  word-wrap: break-word;
  max-width: 90%;
  align-self: flex-start;
  font-size: 14px;
  line-height: 1.4;
  text-align: left; /* Reverted to LTR */
  border: 1px solid transparent; 
  color: #e0e0e0;
}
.my-message {
  background: #d32f2f;
  color: #fff;
  align-self: flex-end;
  text-align: left; /* Reverted to LTR */
  border: 1px solid #d32f2f; 
}
.system-message {
    font-style: italic;
    align-self: center !important;
    max-width: 100% !important;
    text-align: center !important;
    /* Since we stop rendering in chat, this style is only for the history list now */
}
.chat-input-group {
  display: flex;
  gap: 5px;
}
/* Reverting input order for LTR */
#chatNameInput, .team-chat-input-group input[type=text]:first-child {
  width: 30%;
  text-align: center; 
  order: 1; 
}
#chatMsgInput, .team-chat-input-group input[type=text]:nth-child(2) {
  flex-grow: 1;
  text-align: left; 
  order: 2;
}
#sendChatBtn, .team-chat-input-group button {
  background: #d32f2f;
  color: #fff;
  padding: 8px 15px;
  order: 3; 
}

</style>
</head>
<body>

<audio id="team-audio" loop preload="auto">
    <source src="https://raw.githubusercontent.com/ahmadalshaear/eternal-brothers-audio/9b6c092e94f938b6b786aef1c70cce8f43f7ab60/Eternal_Brothers%20_FC_new.mp3" type="audio/mp3">
</audio>
<audio id="notification-sound" preload="auto">
    <source src="https://www.soundjay.com/button/button-3.mp3" type="audio/mp3">
</audio>

<div id="toastContainer"></div> <div class="nav-controls">
  <div class="nav-buttons-top">
    <button id="blueBtn" onclick="showSection('blue')">Blue</button>
    <button id="homeBtn" onclick="showSection('main')">Home</button>
    <button id="yellowBtn" onclick="showSection('yellow')">Yellow</button>
  </div>
  <div class="nav-buttons-bottom">
    <button id="audioToggleBtn" onclick="toggleAudio()">
         
    </button>
  </div>
</div>

<div id="main" class="container">
  <h1 style="margin-top:0; font-size:28px; display:flex; align-items:center; justify-content:center; gap:8px;">
     <span style="color:#1976d2;">Eternal</span> <span style="color:#fbc02d;">Brothers</span> 
  </h1>

  <p style="margin:5px 0; font-weight:bold; color:#fb8c00; font-size:16px;">
    The game will be at 9:40 AM
  </p>

  <p id="addressDisplay" style="margin:5px 0; font-weight:bold; cursor:pointer; color:#9c27b0;">
    Click here to set match address
  </p>

  <h2>Add Player</h2>
  <input type="text" id="nameInput" placeholder="Enter player name">
  <button onclick="addPlayer()">Add</button>

  <h2>Main Team (24 max)</h2>
  <ul id="teamList"></ul>

  <h2>Waiting List</h2>
  <ul id="waitingList"></ul>
  
  <button onclick="loadSystemHistory()" style="background:#6a1b9a; color:#fff; margin-top:15px; width:80%;">Show Join/Leave History</button>
  <div id="systemHistoryContainer" style="margin-top:10px; padding:10px; background:#2c2c2c; border-radius:8px; max-width: 400px; margin-left: auto; margin-right: auto; text-align:left; display:none;">
      <h3 style="margin-top:0;">Event History</h3>
      <ul id="historyList" style="text-align:left; font-weight:normal; font-size:14px; color:#ccc;">
          </ul>
  </div>
  <p style="margin-top:15px; font-size:12px; color:#ccc;">
    We might need to change the football field at any time. Please follow the group chat in case of any changes
  </p>
  
  <div class="chat-container">
    <h2>Group Chat</h2>
    <div id="chatMessages" class="chat-messages">
      </div>
    <div class="chat-input-group">
      <input type="text" id="chatNameInput" placeholder="Your name" value="" style="text-align: center;">
      <input type="text" id="chatMsgInput" placeholder="Type a message..." style="text-align: left;">
      <button id="sendChatBtn" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<div id="blue" class="container" style="background:#1565c0aa;">
  <h2>Blue Team</h2>
  <input type="text" id="blueInput" placeholder="Enter player name">
  <button onclick="addBlue()">Add</button>
  <ul id="blueList"></ul>
  
  <div class="formation-controls">
    <button onclick="applyFormation('blue', '4-4-2')">4-4-2</button>
    <button onclick="applyFormation('blue', '3-4-3')">3-4-3</button>
    <button class="dynamic-btn" onclick="applyDynamicPlan('blue')">Apply Dynamic Plan</button>
  </div>
  
  <h3>Plan</h3>
  <div id="bluePlan" class="field">
    <div class="mid-line"></div>
    <div class="center-circle"></div>
    <div class="penalty-box-left"></div>
    <div class="penalty-box-right"></div>
  </div>

  <div class="chat-container team-chat-container">
    <h3 style="color: #fff;">Blue Team Chat </h3>
    <div id="blueChatMessages" class="chat-messages"></div>
    <div class="chat-input-group team-chat-input-group">
      <input type="text" id="blueChatNameInput" placeholder="Your name" value="">
      <input type="text" id="blueChatMsgInput" placeholder="Message to Blue Team...">
      <button onclick="sendTeamMessage('blue')">Send</button>
    </div>
  </div>
</div>

<div id="yellow" class="container" style="background:#fdd835aa; color:#000;">
  <h2>Yellow Team</h2>
  <input type="text" id="yellowInput" placeholder="Enter player name">
  <button onclick="addYellow()">Add</button>
  <ul id="yellowList"></ul>
  
  <div class="formation-controls">
    <button onclick="applyFormation('yellow', '4-4-2')">4-4-2</button>
    <button onclick="applyFormation('yellow', '3-4-3')">3-4-3</button>
    <button class="dynamic-btn" onclick="applyDynamicPlan('yellow')">Apply Dynamic Plan</button>
  </div>
  
  <h3>Plan</h3>
  <div id="yellowPlan" class="field">
    <div class="mid-line"></div>
    <div class="center-circle"></div>
    <div class="penalty-box-left"></div>
    <div class="penalty-box-right"></div>
  </div>

  <div class="chat-container team-chat-container">
    <h3 style="color: #000;">Yellow Team Chat </h3>
    <div id="yellowChatMessages" class="chat-messages"></div>
    <div class="chat-input-group team-chat-input-group">
      <input type="text" id="yellowChatNameInput" placeholder="Your name" value="">
      <input type="text" id="yellowChatMsgInput" placeholder="Message to Yellow Team...">
      <button onclick="sendTeamMessage('yellow')">Send</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
// =========================================================================================
//  Replace your keys here 
// =========================================================================================
const supabaseUrl = "https://wihhlvgkjglphjzhivdn.supabase.co"; 
const supabaseServiceKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndpaGhsdmdramdscGhqemhpdmRuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5NDMwOTYsImV4cCI6MjA3ODUxOTA5Nn0.0uG2yhtSzNiGfn3f1ZjB0p33lMh75Et28aMgMGznWlQ"; 
const supabase = window.supabase.createClient(supabaseUrl, supabaseServiceKey);
// =========================================================================================

const playerPositions = { blue: {}, yellow: {} };
const nameColors = ["#e53935", "#1e88e5", "#fbc02d","#43a047","#8e24aa","#fb8c00","#00acc1","#d81b60","#6d4c41","#3949ab","#f4511e","#7cb342"];
let audioInitialized = false; 

// ----------------------------------------------------------------------
// ---- FIXED FORMATION DEFINITIONS (12 Players) ------------------------
// ----------------------------------------------------------------------
const FORMATIONS = {
    '4-4-2': [
        { left: '5%', top: '50%' },  // 1. GK
        { left: '25%', top: '10%' }, // 2. DR
        { left: '25%', top: '30%' }, // 3. DC1
        { left: '25%', top: '70%' }, // 4. DC2
        { left: '25%', top: '90%' }, // 5. DL
        { left: '55%', top: '10%' }, // 6. MR
        { left: '55%', top: '30%' }, // 7. MC1
        { left: '55%', top: '70%' }, // 8. MC2
        { left: '55%', top: '90%' }, // 9. ML
        { left: '80%', top: '35%' }, // 10. FW1
        { left: '80%', top: '65%' }, // 11. FW2
        { left: '40%', top: '50%' }, // 12. SUB (Extra)
    ],
    '3-4-3': [
        { left: '5%', top: '50%' },  // 1. GK
        { left: '20%', top: '30%' }, // 2. DC1
        { left: '20%', top: '50%' }, // 3. DC2
        { left: '20%', top: '70%' }, // 4. DC3
        { left: '45%', top: '10%' }, // 5. MR
        { left: '45%', top: '35%' }, // 6. MC1
        { left: '45%', top: '65%' }, // 7. MC2
        { left: '45%', top: '90%' }, // 8. ML
        { left: '75%', top: '25%' }, // 9. FW1
        { left: '75%', top: '50%' }, // 10. FW2
        { left: '75%', top: '75%' }, // 11. FW3
        { left: '10%', top: '95%' }, // 12. SUB (Extra)
    ]
};

function stringToHash(str) {
  let hash = 0;
  if (str.length === 0) return hash;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash |= 0; 
  }
  return Math.abs(hash);
}

function getColorForUsername(username) {
    const hash = stringToHash(username.trim().toUpperCase());
    const index = hash % nameColors.length;
    return nameColors[index];
}

function showSection(id){
  document.querySelectorAll('.container').forEach(c=>c.style.display='none');
  document.getElementById(id).style.display='block';

  // Load team chats when section is shown
  if (id === 'blue') {
    loadTeamChatMessages('blue');
    // Ensure chat name input is populated from global chat name
    document.getElementById('blueChatNameInput').value = localStorage.getItem('chat_username') || '';
  } else if (id === 'yellow') {
    loadTeamChatMessages('yellow');
    document.getElementById('yellowChatNameInput').value = localStorage.getItem('chat_username') || '';
  } else if (id === 'main') {
    loadChatMessages();
  }
}
showSection('main');

function toggleAudio() {
  const audio = document.getElementById('team-audio');
  const toggleBtn = document.getElementById('audioToggleBtn');
  
  if (!audioInitialized) {
    audio.muted = false;
    audio.play().then(() => {
        audioInitialized = true;
        audio.muted = false; 
        toggleBtn.innerHTML = ''; 
    }).catch(e => {
        console.error("Autoplay prevented. Click again to toggle.", e);
        audioInitialized = true;
        audio.muted = true;
        toggleBtn.innerHTML = ''; 
    });
    return;
  }
  
  if (audio.muted) {
    audio.muted = false;
    toggleBtn.innerHTML = ''; 
  } else {
    audio.muted = true;
    toggleBtn.innerHTML = ''; 
  }
}

// ----------------------------------------------------------------------
// ---- TIME RESTRICTION LOGIC (Wednesday 3 PM to Sunday 12 PM) ---------
// ----------------------------------------------------------------------
function isWithinAllowedTime(){
    const now = new Date();
    // 0 = Sunday, 1 = Monday, ..., 3 = Wednesday, ..., 6 = Saturday
    const currentDay = now.getDay(); 
    const currentHour = now.getHours(); // 0-23
    const currentMinute = now.getMinutes();

    // Restriction: From Wednesday 3:00 PM (15:00) until Sunday 12:00 PM (12:00)

    // 1. Days allowed: Wednesday, Thursday, Friday, Saturday, Sunday
    if (currentDay >= 3 && currentDay <= 6) { 
        // Wednesday (3): Must be after 3:00 PM (15:00)
        if (currentDay === 3) {
            return currentHour >= 15;
        }
        // Thursday (4), Friday (5), Saturday (6): Allowed all day
        return true; 
    } else if (currentDay === 0) {
        // Sunday (0): Must be at or before 12:00 PM (12:00)
        if (currentHour < 12) {
            return true;
        } else if (currentHour === 12 && currentMinute === 0) {
            return true;
        }
        return false; // Sunday after 12:00 PM
    }

    // Monday (1) and Tuesday (2) are not allowed
    return false;
}
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// ---- HELPER FUNCTION: Format Time ------------------------------------
// ----------------------------------------------------------------------
function formatPlayerTime(timestamp) {
    if (!timestamp) return '';
    // If the timestamp is a string (ISO format from Supabase), convert it to a number/Date
    const date = new Date(timestamp);
    
    // Format to 12-hour time (e.g., 10:30 PM)
    return date.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit',
        hour12: true,
        numberingSystem: 'latn' 
    });
}

// ----------------------------------------------------------------------
// ---- WEEKLY CLEANUP FUNCTION: SUNDAY 6:00 PM (18:00) -----------------
// ----------------------------------------------------------------------
async function checkAndClearData() {
    const now = new Date();
    
    // 1. Determine the target cleanup time (Sunday 6:00 PM)
    let cleanupTimepoint = new Date(now);
    const currentDay = now.getDay(); // 0 = Sunday
    const currentHour = now.getHours();
    
    // Set the date to the most recent Sunday
    cleanupTimepoint.setDate(now.getDate() - currentDay);
    cleanupTimepoint.setHours(18, 0, 0, 0); // Set time to 6:00 PM (18:00)
    
    // If today is Sunday and it's before 6 PM, the target cleanup time is last Sunday
    if (currentDay === 0 && currentHour < 18) {
        cleanupTimepoint.setDate(cleanupTimepoint.getDate() - 7);
    } 
    
    const lastCleanupTimestamp = localStorage.getItem('last_cleanup_timestamp');
    let lastCleanupDate = lastCleanupTimestamp ? new Date(parseInt(lastCleanupTimestamp)) : new Date(0);

    // 2. Check if cleanup is needed (if the target time is after the last cleanup)
    if (cleanupTimepoint.getTime() > lastCleanupDate.getTime()) {
        console.log("Weekly cleanup required. Clearing data..."); 

        // --- 3. Execute Cleanup ---
        
        // List tables to clear (including new chat tables)
        const tablesToClear = ["main_team", "waiting_list", "blue_team", "yellow_team", "chat_messages", "blue_chat", "yellow_chat"];
        
        await Promise.all(tablesToClear.map(table => {
            // Delete all rows where id is not 0 (assuming id 0 might be a placeholder/config if used)
            return supabase.from(table).delete().neq('id', 0)
                .then(() => console.log(`Table ${table} cleared.`)) 
                .catch(error => console.error(`Error clearing table ${table}:`, error)); 
        }));
        
        // 4. Update the timestamp of the last cleanup
        localStorage.setItem('last_cleanup_timestamp', now.getTime().toString());
        console.log("Cleanup complete. Timestamp updated."); 
        
        // 5. Reload data
        loadPlayers();
        loadBlue();
        loadYellow();
        loadChatMessages();
        loadTeamChatMessages('blue');
        loadTeamChatMessages('yellow');
    } else {
        // console.log("No weekly cleanup required yet."); 
    }
}


// ----------------------------------------------------------------------
// ---- MAIN & WAITING TEAM ----
// ----------------------------------------------------------------------
async function addPlayer(){
  if(!isWithinAllowedTime()){
    alert("Adding players is only allowed from Wednesday 3 PM to Sunday 12 PM.");
    return;
  }
  const name = document.getElementById("nameInput").value.trim();
  if(!name) return alert("Enter a name");
  
  const { data: team } = await supabase.from("main_team").select("id");
  
  if(team.length < 24){
    const { error } = await supabase.from("main_team").insert([{name,time:Date.now()}]);
    if(error) return alert(error.message);
    
    // Log the system message once here, immediately after successful insert
    const message = ` ${name} joined the Main Team!`;
    await sendSystemMessageToChat(name, message);

  } else {
    const { error } = await supabase.from("waiting_list").insert([{name,time:Date.now()}]);
    if(error) return alert(error.message);
    alert("Main team is full (24). Player added to waiting list.");
  }
  
  document.getElementById("nameInput").value="";
  loadPlayers();
}

async function loadPlayers(){
  const { data: team } = await supabase.from("main_team").select("*").order("id");
  const { data: waiting } = await supabase.from("waiting_list").select("*").order("id");
  const teamList = document.getElementById("teamList");
  const waitingList = document.getElementById("waitingList");
  teamList.innerHTML = "";
  waitingList.innerHTML = "";

  if(team) team.forEach((p,i) => {
    const time = formatPlayerTime(p.time); 
    teamList.innerHTML += `
      <li>
        <div class="player-info">
            <span>${i+1}. ${p.name} <span class="player-time">${time}</span></span>
        </div>
        <span>
          <button class="action-btn edit-btn" onclick="editPlayer('main_team',${p.id},'${p.name}')"></button>
          <button class="action-btn delete-btn" onclick="deletePlayer('main_team',${p.id})"></button>
        </span>
      </li>`;
  });

  if(waiting) waiting.forEach((p,i) => {
    const time = formatPlayerTime(p.time); 
    waitingList.innerHTML += `
      <li>
        <div class="player-info">
            <span>${i+1}. ${p.name} <span class="player-time">${time}</span></span>
        </div>
        <span>
          <button class="action-btn edit-btn" onclick="editPlayer('waiting_list',${p.id},'${p.name}')"></button>
          <button class="action-btn delete-btn" onclick="deletePlayer('waiting_list',${p.id})"></button>
        </span>
      </li>`;
  });
}

async function refillMainTeam(){
  const { data: team } = await supabase.from("main_team").select("id");
  const { data: waiting } = await supabase.from("waiting_list").select("*").order("id");
  if(team.length < 24 && waiting.length > 0){
    const first = waiting[0];
    // NOTE: Logging for this automatic insert is NOT needed as it's a side effect.
    await supabase.from("main_team").insert([{ name:first.name, time:Date.now() }]);
    await supabase.from("waiting_list").delete().eq("id", first.id);
  }
}

// ----------------------------------------------------------------------
// ---- BLUE TEAM -------------------------------------------------------
// ----------------------------------------------------------------------
async function addBlue(){
  const name=document.getElementById("blueInput").value.trim();
  if(!name) return;
  const { data: team } = await supabase.from("blue_team").select("id");
  if(team.length >= 12) return alert("Blue team is full (12 players).");
  await supabase.from("blue_team").insert([{name,time:Date.now()}]);
  document.getElementById("blueInput").value="";
  loadBlue();
}

async function loadBlue(){
  const { data } = await supabase.from("blue_team").select("*").order("id");
  const ul=document.getElementById("blueList");
  const field=document.getElementById("bluePlan");
  ul.innerHTML=""; 
  field.innerHTML=`<div class="mid-line"></div><div class="center-circle"></div><div class="penalty-box-left"></div><div class="penalty-box-right"></div>`; 
  if(data) data.forEach((p,i)=>{
    const time = formatPlayerTime(p.time); 
    ul.innerHTML += `
      <li>
        <div class="player-info">
            <span>${i+1}. ${p.name} <span class="player-time">${time}</span></span>
        </div>
        <span>
          <button class="action-btn edit-btn" onclick="editPlayer('blue_team',${p.id},'${p.name}')"></button>
          <button class="action-btn delete-btn" onclick="deletePlayer('blue_team',${p.id})"></button>
        </span>
      </li>`;
    let pos = p.position ? JSON.parse(p.position) : null;
    createPlayerMarker('blue', p.name, i+1, pos);
  });
}

// ----------------------------------------------------------------------
// ---- YELLOW TEAM -----------------------------------------------------
// ----------------------------------------------------------------------
async function addYellow(){
  const name=document.getElementById("yellowInput").value.trim();
  if(!name) return;
  const { data: team } = await supabase.from("yellow_team").select("id");
  if(team.length >= 12) return alert("Yellow team is full (12 players).");
  await supabase.from("yellow_team").insert([{name,time:Date.now()}]);
  document.getElementById("yellowInput").value="";
  loadYellow();
}

async function loadYellow(){
  const { data } = await supabase.from("yellow_team").select("*").order("id");
  const ul=document.getElementById("yellowList");
  const field=document.getElementById("yellowPlan");
  ul.innerHTML=""; 
  field.innerHTML=`<div class="mid-line"></div><div class="center-circle"></div><div class="penalty-box-left"></div><div class="penalty-box-right"></div>`; 
  if(data) data.forEach((p,i)=>{
    const time = formatPlayerTime(p.time); 
    ul.innerHTML += `
      <li>
        <div class="player-info">
            <span>${i+1}. ${p.name} <span class="player-time">${time}</span></span>
        </div>
        <span>
          <button class="action-btn edit-btn" onclick="editPlayer('yellow_team',${p.id},'${p.name}')"></button>
          <button class="action-btn delete-btn" onclick="deletePlayer('yellow_team',${p.id})"></button>
        </span>
      </li>`;
    let pos = p.position ? JSON.parse(p.position) : null;
    createPlayerMarker('yellow', p.name, i+1, pos);
  });
}

// ----------------------------------------------------------------------
// ---- FIXED FORMATION APPLICATION (12 Players) ------------------------
// ----------------------------------------------------------------------
async function applyFormation(team, formationName) {
    const table = team === 'blue' ? 'blue_team' : 'yellow_team';
    const formation = FORMATIONS[formationName];
    
    // 1. Get the current list of players (up to 12)
    const { data: players, error } = await supabase.from(table).select('id').order('id', { ascending: true });
    
    if (error || !players || players.length === 0) {
        alert(`No players found in the ${team} team to apply formation.`);
        return;
    }

    const updates = players.slice(0, 12).map((player, index) => {
        const pos = formation[index];
        const positionString = JSON.stringify({ 
            left: pos.left, 
            top: pos.top 
        });
        
        // 2. Prepare the update query for each player
        return supabase.from(table)
            .update({ position: positionString })
            .eq('id', player.id)
            .select(); 
    });

    // 3. Execute all updates simultaneously
    const results = await Promise.all(updates);
    
    // 4. Alert and rely on Realtime
    alert(`${formationName} formation applied successfully to the ${team} team.`);
}

// ----------------------------------------------------------------------
// ---- NEW DYNAMIC FORMATION LOGIC -------------------------------------
// ----------------------------------------------------------------------

// Function to generate positions dynamically based on player count (N)
function getDynamicFormation(N) {
    if (N === 0) return [];

    // Define slices based on player index (1 to 12+) and the target X-coordinate
    // X: Left % of the field. Y_count: Max players allocated to this line.
    const distributionMap = [];
    distributionMap.push({ X: 5, Y_count: 1 }); // P1: GK @ 5%
    distributionMap.push({ X: 25, Y_count: 4 }); // P2-P5: DEF @ 25%
    distributionMap.push({ X: 55, Y_count: 4 }); // P6-P9: MID @ 55%
    distributionMap.push({ X: 80, Y_count: 3 }); // P10-P12: ATT @ 80%
    
    // Handle Substitutes if N > 12 (Though team max is 12, this is safe)
    if (N > 12) {
        distributionMap.push({ X: 10, Y_count: N - 12 }); 
    }

    const positions = [];
    let currentPlayerIndex = 1;

    for (const zone of distributionMap) {
        if (currentPlayerIndex > N) break;

        // Calculate how many actual players will be in this zone
        let playersInZone = Math.min(zone.Y_count, N - currentPlayerIndex + 1);
        if (playersInZone === 0) continue;
        
        // Distribution parameters (Y-axis spread)
        const Y_min = 10;
        const Y_max = 90;
        // Calculate the step size between players for even vertical spread
        let deltaY = playersInZone > 1 ? (Y_max - Y_min) / (playersInZone - 1) : 0;

        for (let j = 0; j < playersInZone; j++) {
            let top;
            if (playersInZone === 1) {
                top = 50; // Center if only one player in the line (e.g., GK)
            } else {
                top = Y_min + j * deltaY;
            }

            positions.push({
                left: `${zone.X}%`,
                top: `${top.toFixed(2)}%`
            });

            currentPlayerIndex++;
        }
    }
    return positions;
}

// Function to apply the dynamic plan based on current player count
async function applyDynamicPlan(team) {
    const table = team === 'blue' ? 'blue_team' : 'yellow_team';
    
    // 1. Get the current list of players and count (N)
    const { data: players, error } = await supabase.from(table).select('id').order('id', { ascending: true });
    
    if (error || !players || players.length === 0) {
        alert(`No players found in the ${team} team to apply the dynamic plan.`);
        return;
    }
    
    const N = players.length;
    
    // 2. Generate the dynamic formation based on N
    const dynamicFormation = getDynamicFormation(N);
    
    // 3. Prepare the update queries
    const updates = players.map((player, index) => {
        // Only update up to the number of generated positions (N should match).
        if (index < dynamicFormation.length) {
            const pos = dynamicFormation[index];
            const positionString = JSON.stringify({ 
                left: pos.left, 
                top: pos.top 
            });
            return supabase.from(table)
                .update({ position: positionString })
                .eq('id', player.id)
                .select();
        }
        return null; 
    }).filter(update => update !== null); 

    // 4. Execute all updates simultaneously
    const results = await Promise.all(updates);
    
    // 5. Alert and rely on Realtime
    alert(`Dynamic plan applied successfully for ${N} players in the ${team} team.`);
}
// ----------------------------------------------------------------------


// ----------------------------------------------------------------------
// ---- DELETE FUNCTION -------------------------------------------------
// ----------------------------------------------------------------------
async function deletePlayer(table,id){
  let playerName = "";
  let isMainTeam = table === "main_team";

  // If deleting from main_team, find the name and send chat alert
  if (isMainTeam) {
      const { data, error } = await supabase.from(table).select('name').eq("id", id).single();
      if (data) {
          playerName = data.name;
      }
  }
  
  if(!confirm("Are you sure you want to delete this player?")) return;
  
  // Send chat alert BEFORE deletion on the database (for history log, only once)
  if (isMainTeam && playerName) {
      const message = ` ${playerName} left the Main Team.`;
      await sendSystemMessageToChat(playerName, message);
  }

  await supabase.from(table).delete().eq("id",id);
  
  if(table==="main_team") await refillMainTeam(); 
  reloadList(table);
}

async function editPlayer(table,id,oldName){
  const newName=prompt("Edit name:", oldName);
  if(!newName || newName.trim()==="") return;
  await supabase.from(table).update({name:newName.trim()}).eq("id",id);
  reloadList(table);
}

function reloadList(table){
  if(table==="main_team" || table==="waiting_list") loadPlayers();
  else if(table==="blue_team") loadBlue();
  else if(table==="yellow_team") loadYellow();
}

// ---- PLAYER MARKERS (Original Drag and Drop Logic) ----
function createPlayerMarker(team, playerName, playerIndex, storedPosition=null) {
  const fieldId = team === 'blue' ? 'bluePlan' : 'yellowPlan';
  const field = document.getElementById(fieldId);

  const marker = document.createElement('div');
  marker.classList.add('player-marker');
  marker.style.background = team==='blue'? '#1976d2' : '#fbc02d';
  marker.innerText = playerIndex;

  if(storedPosition){
    // Use stored coordinates (from drag or applied formation)
    marker.style.left = storedPosition.left;
    marker.style.top = storedPosition.top;
  } else {
    // Default fallback position
    marker.style.left = '10px';
    marker.style.top = `${30 + playerIndex * 30}px`;
  }

  const label = document.createElement('div');
  label.classList.add('player-name');
  label.innerText = playerName;
  label.style.color = 'black';
  marker.appendChild(label);

  let isDragging=false, offsetX, offsetY;

  function startDrag(e){
    isDragging=true;
    e.preventDefault(); 
    const rect=marker.getBoundingClientRect();
    if(e.type.startsWith('touch')){
      const touch=e.touches[0];
      offsetX=touch.clientX - rect.left;
      offsetY=touch.clientY - rect.top;
    } else {
      offsetX=e.clientX - rect.left;
      offsetY=e.clientY - rect.top;
    }
  }

  function moveDrag(e){
    if(!isDragging) return;
    e.preventDefault(); 
    const rect=field.getBoundingClientRect();
    let clientX, clientY;
    if(e.type.startsWith('touch')){
      const touch=e.touches[0];
      clientX=touch.clientX;
      clientY=touch.clientY;
    } else {
      clientX=e.clientX;
      clientY=e.clientY;
    }
    
    let newLeft = clientX - rect.left - offsetX;
    let newTop = clientY - rect.top - offsetY;

    newLeft = Math.max(0, Math.min(newLeft, rect.width - marker.offsetWidth));
    newTop = Math.max(0, Math.min(newTop, rect.height - marker.offsetHeight));
    
    marker.style.left = `${newLeft}px`;
    marker.style.top = `${newTop}px`;
  }

  async function endDrag(){
    if(!isDragging) return;
    isDragging=false;
    
    // Save position as percentages for responsiveness
    const fieldRect = field.getBoundingClientRect();
    const leftPercent = (parseFloat(marker.style.left) / fieldRect.width) * 100;
    const topPercent = (parseFloat(marker.style.top) / fieldRect.height) * 100;
    
    const positionData = { 
        left: `${leftPercent.toFixed(2)}%`, 
        top: `${topPercent.toFixed(2)}%` 
    };
    
    playerPositions[team][playerName] = positionData;
    
    const table = team==='blue' ? 'blue_team' : 'yellow_team';
    // Find the player's ID and update their position
    const { data: player } = await supabase.from(table).select('id').eq('name',playerName).limit(1);
    if(player.length>0){
      await supabase.from(table).update({position: JSON.stringify(positionData)}).eq('id', player[0].id);
    }
  }

  marker.addEventListener('mousedown', startDrag);
  marker.addEventListener('touchstart', startDrag);
  document.addEventListener('mousemove', moveDrag);
  document.addEventListener('touchmove', moveDrag);
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('touchend', endDrag);

  field.appendChild(marker);
}

// ----------------------------------------------------------------------
//  FIXED: MATCH ADDRESS PERSISTENCE (Double-Click Edit without Prompts/Alerts) 
// ----------------------------------------------------------------------

const addressDisplayElem = document.getElementById('addressDisplay');

// Function to load the address from Supabase
async function loadMatchAddress() {
    const { data, error } = await supabase
        .from('app_config')
        .select('match_address')
        .eq('id', 1) 
        .single(); 
        
    if (error && error.code !== 'PGRST116' && error.details !== 'The result contains 0 rows') {
        console.error("Error loading address from DB:", error);
    } 

    const savedAddress = data ? data.match_address : null;

    if (savedAddress && savedAddress.trim() !== '') {
        addressDisplayElem.textContent = savedAddress;
    } else {
        addressDisplayElem.textContent = "Click here to set match address";
    }
}

// Function to save the address to Supabase (FIXED: Uses UPDATE, then INSERT if UPDATE fails)
async function saveMatchAddress(address) {
    const defaultText = "Click here to set match address";
    const addressToSave = address.trim() || '';
    
    // 1. Attempt UPDATE
    const { data: updateData, error: updateError } = await supabase
        .from('app_config')
        .update({ match_address: addressToSave })
        .eq('id', 1) 
        .select();

    if (updateError) {
        console.error("Error during UPDATE attempt:", updateError.message);
    }
    
    // 2. If UPDATE failed or returned no rows, attempt INSERT
    if (!updateData || updateData.length === 0) {
        const { error: insertError } = await supabase
            .from('app_config')
            .insert([{ id: 1, match_address: addressToSave }]);
            
        if (insertError) {
            console.error("Error during INSERT attempt:", insertError.message);
            return;
        }
    }
    
    // 3. Update the display element (text content)
    document.getElementById('addressDisplay').textContent = addressToSave || defaultText;
}


// Attach the double-click handler for in-line editing (NO PROMPT/ALERT)
addressDisplayElem.addEventListener('dblclick', function() {
    // Get current text, filtering out the placeholder
    const currentText = addressDisplayElem.textContent.includes("Click here") ? "" : addressDisplayElem.textContent.trim();
    
    // 1. Create the input element
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentText;
    // Apply necessary styles
    input.style.cssText = 'padding: 5px; width: 80%; border-radius: 5px; border: 1px solid #9c27b0; margin: 0; background: #2c2c2c; color: #fff; text-align: center; font-family: "Cairo", sans-serif; font-size: 16px; font-weight: bold;';
    
    // 2. Replace the P element with the Input element
    addressDisplayElem.replaceWith(input);
    input.focus();
    
    // 3. Define the save and replace logic
    const saveAndReplace = async () => {
        // Prevent double saving if triggered by both enter and blur
        if (input.parentNode === null) return; 

        const newAddress = input.value;
        const p = document.createElement('p');
        p.id = 'addressDisplay';
        
        // Copy original styles for the new P element
        p.style.cssText = 'margin:5px 0; font-weight:bold; cursor:pointer; color:#9c27b0;'; 

        input.replaceWith(p); // Replace the input with the new P element
        
        await saveMatchAddress(newAddress); // Save to DB and update the new P's content
        
        // Re-attach the double-click listener to the newly created P element
        p.addEventListener('dblclick', arguments.callee); 
    };
    
    // 4. Attach event listeners to the input field
    // Save on losing focus (blur)
    input.addEventListener('blur', saveAndReplace, { once: true });
    
    // Save on Enter key press
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault(); 
            // Explicitly remove blur listener to prevent double save on Enter
            input.removeEventListener('blur', saveAndReplace, { once: true }); 
            saveAndReplace();
        }
    });

}, false); 


// ----------------------------------------------------------------------
// ---- CHAT & HISTORY FUNCTIONS ----------------------------------------
// ----------------------------------------------------------------------

function playNotificationSound() {
    const sound = document.getElementById('notification-sound');
    sound.currentTime = 0; 
    sound.play().catch(e => console.log("Notification sound blocked:", e));
}

// Function to log system events to the chat_messages table (for history)
async function sendSystemMessageToChat(playerName, content) {
    const systemUsername = `System-Alert-(${playerName})`; 
    const { error } = await supabase
        .from('chat_messages')
        .insert([{ username: systemUsername, content }]); 
    
    if (error) {
        console.error('Error sending system message:', error);
    }
}

// Modified renderMessage to accept container ID
function renderMessage(message, containerId) {
  const messagesContainer = document.getElementById(containerId);
  if (!messagesContainer) return;

  const msgDiv = document.createElement('div');
  msgDiv.classList.add('message');
  
  const storedName = localStorage.getItem('chat_username');
  const isMyMessage = storedName && storedName.trim() === message.username.trim();
  
  const nameColor = getColorForUsername(message.username);

  if (isMyMessage) {
    msgDiv.classList.add('my-message');
  } else {
    msgDiv.style.borderColor = nameColor;
    msgDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.05)'; 
  }

  const date = new Date(message.created_at).toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: true, 
    numberingSystem: 'latn' 
  });
  
  const timeSpan = `<span style="color:#888;">${date}</span>`;

  msgDiv.innerHTML = `
    <span class="message-header" style="color: ${nameColor};">${message.username} ${timeSpan}</span>
    <span>${message.content}</span>
  `;
  
  messagesContainer.appendChild(msgDiv); 
  messagesContainer.scrollTop = messagesContainer.scrollHeight; 
}

// MODIFIED: Exclude system messages when loading initial chat
async function loadChatMessages() {
  const { data, error } = await supabase
    .from('chat_messages')
    .select('*')
    .not('username', 'like', 'System-Alert-%') // Exclude System Alerts
    .order('created_at', { ascending: true }) 
    .limit(50); 

  if (error) {
    console.error('Error loading chat messages:', error);
    return;
  }

  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.innerHTML = ''; 
  data.forEach(msg => renderMessage(msg, 'chatMessages'));
  
  messagesContainer.scrollTop = messagesContainer.scrollHeight; 
}

async function sendMessage() {
  const nameInput = document.getElementById('chatNameInput');
  const msgInput = document.getElementById('chatMsgInput');
  
  const username = nameInput.value.trim();
  const content = msgInput.value.trim();

  if (!username) {
    return alert("Please enter your name.");
  }
  if (!content) {
    return alert("Cannot send an empty message.");
  }

  localStorage.setItem('chat_username', username);

  const { error } = await supabase
    .from('chat_messages')
    .insert([{ username, content }]); 

  if (error) {
    console.error('Error sending message:', error);
    return alert(`Error sending message: ${error.message}`);
  }

  msgInput.value = ''; 
  
  playNotificationSound();
}

// ----------------------------------------------------------------------
// ---- NEW TEAM CHAT FUNCTIONS -----------------------------------------
// ----------------------------------------------------------------------

async function loadTeamChatMessages(team) {
    const table = `${team}_chat`; // 'blue_chat' or 'yellow_chat'
    const containerId = `${team}ChatMessages`;

    const { data, error } = await supabase
        .from(table)
        .select('*')
        .order('created_at', { ascending: true }) 
        .limit(50); 

    const messagesContainer = document.getElementById(containerId);
    if (error) {
        console.error(`Error loading ${team} chat messages:`, error);
        messagesContainer.innerHTML = '<div class="message">Error loading chat. Make sure the table exists.</div>';
        return;
    }

    messagesContainer.innerHTML = ''; 
    data.forEach(msg => renderMessage(msg, containerId));
    messagesContainer.scrollTop = messagesContainer.scrollHeight; 
}

async function sendTeamMessage(team) {
    const nameInputId = `${team}ChatNameInput`;
    const msgInputId = `${team}ChatMsgInput`;
    const table = `${team}_chat`; 

    const username = document.getElementById(nameInputId).value.trim();
    const content = document.getElementById(msgInputId).value.trim();

    if (!username) {
        return alert("Please enter your name.");
    }
    if (!content) {
        return alert("Cannot send an empty message.");
    }

    // Also update the global chat name for consistency
    localStorage.setItem('chat_username', username); 
    document.getElementById('chatNameInput').value = username;
    document.getElementById('blueChatNameInput').value = username;
    document.getElementById('yellowChatNameInput').value = username;

    const { error } = await supabase
        .from(table)
        .insert([{ username, content }]); 

    if (error) {
        console.error(`Error sending ${team} message:`, error);
        return alert(`Error sending message: ${error.message}`);
    }

    document.getElementById(msgInputId).value = ''; 
    playNotificationSound();
}

// ----------------------------------------------------------------------
// ---- HISTORY & REALTIME SETUP ----------------------------------------
// ----------------------------------------------------------------------

// NEW/MODIFIED: Function to load and display system history (with duplication fix)
async function loadSystemHistory(toggle = true) {
  const historyContainer = document.getElementById('systemHistoryContainer');
  const historyList = document.getElementById('historyList');
  
  // Only toggle visibility if requested (i.e., when button is clicked)
  if (toggle) {
    historyContainer.style.display = historyContainer.style.display === 'block' ? 'none' : 'block';
  }
  
  if (historyContainer.style.display === 'none') return;
  
  // FIX: Clear the list COMPLETELY on every load to prevent duplicates
  historyList.innerHTML = '<li>Loading history...</li>'; 

  const { data, error } = await supabase
    .from('chat_messages')
    .select('content, created_at')
    .like('username', 'System-Alert-%') // Filter for system messages
    .order('created_at', { ascending: false })
    .limit(50);

  if (error) {
    console.error('Error loading system history:', error);
    historyList.innerHTML = '<li>Error loading history.</li>';
    return;
  }

  if (data.length === 0) {
    historyList.innerHTML = '<li>No recent join/leave events.</li>';
    return;
  }
  
  historyList.innerHTML = ''; // Final clear before inserting elements
  
  data.forEach(item => {
    // Formatting Date and Time
    const date = new Date(item.created_at).toLocaleDateString('en-US');
    const time = new Date(item.created_at).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
    
    let color = '#fff';
    let label = 'Event: ';
    
    if (item.content.includes('joined')) {
        color = '#81c784'; // Light green for join
        label = ' Joined: ';
    } else if (item.content.includes('left')) {
        color = '#ef9a9a'; // Light red for leave
        label = ' Left: ';
    }
    
    // Clean up content to show player name clearly
    const playerName = item.content.replace(' ', '').replace(' ', '').replace(' joined the Main Team!', '').replace(' left the Main Team.', '');

    historyList.innerHTML += `
      <li style="color:${color}; border-bottom: 1px dotted #333; padding-bottom: 5px; margin-bottom: 5px;">
        ${label} **${playerName}**
        <span style="float:right; color:#999; font-size:12px;">${date} at ${time}</span>
      </li>
    `;
  });
}

function setupRealtime() {
  // 1. GLOBAL CHAT MESSAGES REALTIME
  supabase
    .channel('global-chat-updates')
    .on(
      'postgres_changes',
      { event: 'INSERT', schema: 'public', table: 'chat_messages' },
      (payload) => {
        const storedName = localStorage.getItem('chat_username'); 
        const incomingUsername = payload.new.username.trim();

        // Check if the message is a System Alert
        if (incomingUsername.startsWith('System-Alert-(')) {
            const historyContainer = document.getElementById('systemHistoryContainer');
            if (historyContainer.style.display === 'block') {
                 loadSystemHistory(false); 
            }
            return; 
        }
        
        if (storedName && storedName.trim() !== incomingUsername) {
            playNotificationSound();
        }
        
        renderMessage(payload.new, 'chatMessages'); // Use renderMessage with container ID
      }
    )
    .subscribe();
    
    // 2. BLUE TEAM CHAT REALTIME
    supabase
    .channel('blue-chat-updates')
    .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'blue_chat' },
        (payload) => {
            const storedName = localStorage.getItem('chat_username');
            if (storedName && storedName.trim() !== payload.new.username.trim()) {
                playNotificationSound();
            }
            // Only update if on the blue page
            if(document.getElementById('blue').style.display === 'block') {
              renderMessage(payload.new, 'blueChatMessages');
            }
        }
    )
    .subscribe();

    // 3. YELLOW TEAM CHAT REALTIME
    supabase
    .channel('yellow-chat-updates')
    .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'yellow_chat' },
        (payload) => {
            const storedName = localStorage.getItem('chat_username');
            if (storedName && storedName.trim() !== payload.new.username.trim()) {
                playNotificationSound();
            }
            // Only update if on the yellow page
            if(document.getElementById('yellow').style.display === 'block') {
              renderMessage(payload.new, 'yellowChatMessages');
            }
        }
    )
    .subscribe();
    
    // 4. MAIN TEAM REALTIME UPDATES
    supabase
    .channel('main-team-updates')
    // Listen for all changes (INSERT, UPDATE, DELETE) to trigger list reload and possible refill
    .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'main_team' },
        async (payload) => {
            loadPlayers(); // Refresh the list
            if(payload.eventType === 'DELETE') {
                await refillMainTeam(); // Check and refill only on delete
            }
        }
    )
    .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'waiting_list' },
        async (payload) => {
            loadPlayers(); 
        }
    )
    .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'blue_team' },
        async (payload) => {
            loadBlue(); 
        }
    )
    .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'yellow_team' },
        async (payload) => {
            loadYellow(); 
        }
    )
    .subscribe();
}


// ----------------------------------------------------------------------
// ---- INITIAL LOAD & SETUP ----------------------------------------------
// ----------------------------------------------------------------------

// Load username from local storage if available
const storedUsername = localStorage.getItem('chat_username');
if (storedUsername) {
  document.getElementById('chatNameInput').value = storedUsername;
  // Also pre-fill the team chat name inputs
  document.getElementById('blueChatNameInput').value = storedUsername;
  document.getElementById('yellowChatNameInput').value = storedUsername;
}

// Add event listener for sending global message with Enter key
document.getElementById('chatMsgInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    sendMessage();
  }
});
// Add event listeners for sending team messages with Enter key
document.getElementById('blueChatMsgInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    sendTeamMessage('blue');
  }
});
document.getElementById('yellowChatMsgInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    sendTeamMessage('yellow');
  }
});


// ** NEW: Check and perform scheduled cleanup (Sunday 6 PM) **
checkAndClearData(); 

loadPlayers(); 
loadBlue(); 
loadYellow(); 
loadChatMessages();
// Note: Team chats are loaded when their section is opened via showSection()
loadMatchAddress(); 
setupRealtime();
</script>
</body>
</html>
