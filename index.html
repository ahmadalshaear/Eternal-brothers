<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Eternal Brothers FC</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
<style>
/* ... (All CSS styles remain exactly the same as before) ... */
/* -------------------- 1. GENERAL & BODY STYLES -------------------- */
body {
  font-family: "Cairo", sans-serif;
  background-color: #121212;
  color: #e0e0e0;
  margin:0;
  padding:10px;
  text-align:center;
}
.container {
  display:none;
  max-width:95%;
  margin:auto;
  background:#1e1e1ecc;
  padding:20px 10px;
  border-radius:15px;
  box-shadow:0 0 10px #000;
}
h1,h2,h3 { margin:10px 0; }
input[type=text] { 
    padding:8px; 
    width:80%; 
    border-radius:8px; 
    border:1px solid #555; 
    margin:5px 0; 
    background:#2c2c2c; 
    color:#fff; 
    text-align:center; 
}
button {
  padding:10px 16px;
  border:none;
  border-radius:8px;
  cursor:pointer;
  font-weight:700;
}
.formation-controls button {
    margin: 5px 3px;
    background: #009688; 
    color: #fff;
    padding: 8px 12px;
    font-size: 14px;
}
.formation-controls .dynamic-btn {
    background: #FF9800; 
    font-weight: 700;
}

/* -------------------- 2. NAV CONTROLS -------------------- */
.nav-controls {
  margin-bottom: 20px;
  display: flex;
  flex-direction: column; 
  align-items: center; 
}
.nav-buttons-top {
  display: flex;
  flex-direction: row; 
  justify-content: space-between;
  width: 100%; 
  max-width: 400px; 
  margin-bottom: 5px; 
}
.nav-buttons-bottom {
  display: flex;
  justify-content: center; 
  width: 100%;
  max-width: 400px;
}
#homeBtn, #blueBtn, #yellowBtn {
    width: 100%; 
    margin: 0 5px; 
}
#homeBtn { background:#d32f2f; color:#fff; }
#blueBtn { background:#1976d2; color:#fff; }
#yellowBtn { background:#fbc02d; color:#000; }

/* New Settings Button Style */
.settings-audio-group {
    display: flex;
    gap: 5px; 
    width: 100%;
    justify-content: center;
}
#audioToggleBtn { 
  background: #616161 !important;
  color: #fff !important;
  font-size: 16px;
  padding: 8px 12px;
  width: calc(50% - 2.5px); 
  margin: 0; 
  border-radius: 8px; 
}
#settingsBtn {
  background: #795548 !important;
  color: #fff !important;
  font-size: 16px;
  padding: 8px 12px;
  width: calc(50% - 2.5px);
  margin: 0; 
  border-radius: 8px; 
}

/* -------------------- 3. LISTS & PLAYER INFO -------------------- */
ul { 
    list-style:none; 
    padding:0; 
    margin-top:10px; 
    text-align:left; 
    font-weight:bold; 
}
li { 
    margin:5px 0; 
    padding:6px; 
    border-radius:8px; 
    display:flex; 
    justify-content:space-between; 
    align-items:center;
    flex-direction: row; 
    min-height: 40px; 
}
#teamList li { background:#a8e6a1; color:black; }
#waitingList li { background:#ffe0e0; color:black; }
#blueList li { background:rgba(25,118,210,0.7); color:white; }
#yellowList li { background:rgba(251,192,42,0.7); color:#000; }

.player-info {
    display: flex;
    flex-direction: row; 
    align-items: center; 
    font-size: 16px;
    font-weight: bold;
}
.player-time {
    font-size: 12px;
    font-weight: normal;
    color: #616161; 
    margin-left: 5px; 
}

.action-btn {
  margin-left:6px;
  border:none;
  border-radius:5px;
  padding:4px 8px;
  cursor:pointer;
  font-weight:bold;
}
.edit-btn { background:#4caf50; color:#fff; }
.delete-btn { background:#e53935; color:#fff; }

/* -------------------- 4. FIELD & MARKER STYLES -------------------- */
.field { width:100%; max-width:400px; height:250px; background:#4CAF50; margin:10px auto; border:2px solid #fff; border-radius:10px; position:relative; touch-action:none; }
.field .center-circle { position:absolute; width:50px;height:50px;border-radius:50%;border:2px solid #fff; top:50%; left:50%; transform:translate(-50%,-50%); }
.field .penalty-box-left, .field .penalty-box-right { position:absolute;width:60px;height:120px;border:2px solid #fff; top:50%; transform:translateY(-50%); }
.field .penalty-box-left { left:0; }
.field .penalty-box-right { right:0; }
.field .mid-line { position:absolute; width:0;height:100%;border-left:2px solid #fff; top:0; left:50%; transform:translateX(-50%); }

.player-marker { 
  width:35px; 
  height:35px; 
  border-radius:50%; 
  color:#fff; 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  font-size:14px; 
  font-weight:bold; 
  position:absolute; 
  cursor:pointer; 
  user-select:none; 
  border: 2px solid rgba(255, 255, 255, 0.5); 
  touch-action: none; 
  transform: translate(-50%, -50%); 
}
.player-name {
  position: absolute;
  top: -18px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 12px;
  color: black;
  white-space: nowrap;
  font-weight: bold;
}
.player-position-label {
    font-size: 14px;
    font-weight: bold;
    color: white;
}

/* -------------------- 5. CHAT STYLES -------------------- */
.chat-container {
  width: 100%; 
  max-width: 100%; 
  margin: 20px 0 0 0;
  background: #242424;
  border-radius: 10px;
  padding: 10px;
  box-shadow: 0 0 5px #000;
  text-align: left; 
}
.team-chat-container {
  background: none;
  box-shadow: none;
  margin: 5px 0 0 0;
  padding: 0;
}
.chat-messages {
  height: 250px;
  overflow-y: auto;
  margin-bottom: 10px;
  padding: 5px;
  background: #1e1e1e;
  border-radius: 5px;
  display: flex;
  flex-direction: column;
  text-align: left; 
}
#blueChatMessages { background: rgba(25, 118, 210, 0.1); }
#yellowChatMessages { background: rgba(251, 192, 42, 0.1); }
.message {
  margin-bottom: 8px;
  padding: 8px;
  border-radius: 10px;
  background: #333; 
  word-wrap: break-word;
  max-width: 90%;
  align-self: flex-start;
  font-size: 14px;
  line-height: 1.4;
  text-align: left; 
  border: 1px solid transparent; 
  color: #e0e0e0;
}
.my-message {
  background: #d32f2f;
  color: #fff;
  align-self: flex-end;
  text-align: left; 
  border: 1px solid #d32f2f; 
}
.chat-input-group {
  display: flex;
  gap: 5px;
}
#chatNameInput, .team-chat-input-group input[type=text]:first-child {
  width: 30%;
  text-align: center; 
  order: 1; 
}
#chatMsgInput, .team-chat-input-group input[type=text]:nth-child(2) {
  flex-grow: 1;
  text-align: left; 
  order: 2;
}
#sendChatBtn, .team-chat-input-group button {
  background: #d32f2f;
  color: #fff;
  padding: 8px 15px;
  order: 3; 
}

/* -------------------- 6. POSITION MENU MODAL STYLES -------------------- */
.position-menu-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}
.position-menu-box {
    background-color: #2c2c2c;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    width: 90%;
    max-width: 350px;
    text-align: center;
}
.position-menu-box h3 {
    margin-top: 0;
    color: #fff;
    font-size: 18px;
}
.position-menu-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 15px;
}
.position-menu-grid button {
    padding: 12px 5px;
    font-size: 14px;
    background-color: #444;
    color: #fff;
    border-radius: 6px;
    transition: background-color 0.2s;
}
.position-menu-grid button:hover {
    background-color: #d32f2f;
}

/* -------------------- 7. SETTINGS MODAL STYLES (NEW) -------------------- */
.settings-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    display: none; /* Controlled by JS */
    justify-content: center;
    align-items: center;
    z-index: 2000;
    padding: 10px;
}
.settings-modal-content {
    background-color: #1e1e1e;
    padding: 25px;
    border-radius: 15px;
    box-shadow: 0 5px 25px rgba(0, 0, 0, 0.8);
    width: 95%;
    max-width: 450px;
    text-align: left;
    color: #fff;
}
.settings-modal-content h2 {
    text-align: center;
    color: #d32f2f;
    margin-bottom: 20px;
}
.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid #333;
}
.setting-item:last-child {
    border-bottom: none;
}
.setting-item label {
    font-weight: 600;
    font-size: 15px;
}
.setting-item input[type="checkbox"] {
    transform: scale(1.5);
    cursor: pointer;
}
.password-input-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    margin-bottom: 20px;
}
.password-input-group input[type="password"] {
    width: 70%;
    text-align: center;
    font-size: 16px;
}
.settings-footer {
    text-align: center;
    margin-top: 20px;
}
#saveSettingsBtn {
    background: #1976d2;
    color: #fff;
    width: 100%;
    padding: 12px;
}
</style>
</head>
<body>

<audio id="musicPlayer" loop preload="auto">
    <source src="https://raw.githubusercontent.com/ahmadalshaear/eternal-brothers-audio/main/Eternal_Brothers%20_FC_new.mp3" type="audio/mp3">
</audio>
<audio id="notification-sound" preload="auto">
    <source src="https://www.soundjay.com/button/button-3.mp3" type="audio/mp3">
</audio>

<div id="toastContainer"></div> 

<div class="nav-controls">
  <div class="nav-buttons-top">
    <button id="blueBtn" onclick="showSection('blue')">Blue Team</button>
    <button id="homeBtn" onclick="showSection('main')">Home</button>
    <button id="yellowBtn" onclick="showSection('yellow')">Yellow Team</button>
  </div>
  <div class="nav-buttons-bottom">
    <div class="settings-audio-group">
        <button id="audioToggleBtn" onclick="toggleBackgroundMusic()">
            Audio</button>
        <button id="settingsBtn" onclick="showSettingsModal()">
            &#9881;</button> 
    </div>
  </div>
</div>

<div id="main" class="container">
  <h1 style="margin-top:0; font-size:28px; display:flex; align-items:center; justify-content:center; gap:8px;">
    &#9917; <span style="color:#1976d2;">Eternal</span> <span style="color:#fbc02d;">Brothers</span> &#9917;
  </h1>

  <p style="margin:5px 0; font-weight:bold; color:#fb8c00; font-size:16px;">
    The game will be at 9:40 AM
  </p>

  <p id="addressDisplay" style="margin:5px 0; font-weight:bold; cursor:pointer; color:#9c27b0;">
    Click here to set match address
  </p>
  
  <div id="playerManagement">
    <h2>Add Player</h2>
    <input type="text" id="nameInput" placeholder="Enter player name">
    <button id="addPlayerBtn" onclick="addPlayer()">Add</button>
  </div>

  <h2>Main Team (24 max)</h2>
  <ul id="teamList"></ul>

  <h2>Waiting List</h2>
  <ul id="waitingList"></ul>
  
  <button onclick="loadSystemHistory()" style="background:#6a1b9a; color:#fff; margin-top:15px; width:80%;">Show Join/Leave History</button>
  <div id="systemHistoryContainer" style="margin-top:10px; padding:10px; background:#2c2c2c; border-radius:8px; max-width: 400px; margin-left: auto; margin-right: auto; text-align:left; display:none;">
      <h3 style="margin-top:0;">Event History</h3>
      <ul id="historyList" style="text-align:left; font-weight:normal; font-size:14px; color:#ccc;">
          </ul>
  </div>
  <p style="margin-top:15px; font-size:12px; color:#ccc;">
    We might need to change the football field at any time. Please follow the group chat in case of any changes
  </p>
  
  <div class="chat-container">
    <h2>Group Chat</h2>
    <div id="chatMessages" class="chat-messages">
      </div>
    <div class="chat-input-group">
      <input type="text" id="chatNameInput" placeholder="Your name" value="" style="text-align: center;">
      <input type="text" id="chatMsgInput" placeholder="Type a message...">
      <button id="sendChatBtn" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<div id="blue" class="container" style="background:#1565c0aa;">
  <h2>Blue Team</h2>
  <div id="bluePlayerManagement">
    <input type="text" id="blueInput" placeholder="Enter player name">
    <button id="addBlueBtn" onclick="addBlue()">Add</button>
  </div>
  <ul id="blueList"></ul>
  
  <div class="formation-controls">
    <button class="formation-btn" onclick="applyFormation('blue', '4-3-3')">4-3-3</button>
    <button class="formation-btn" onclick="applyFormation('blue', '4-4-2')">4-4-2</button>
    <button class="formation-btn" onclick="applyFormation('blue', '3-4-3')">3-4-3</button>
    <button id="blueDynamicBtn" class="dynamic-btn" onclick="applyDynamicPlan('blue')">Apply Dynamic Plan</button>
  </div>
  
  <h3>Plan</h3>
  <div id="bluePlan" class="field">
    <div class="mid-line"></div>
    <div class="center-circle"></div>
    <div class="penalty-box-left"></div>
    <div class="penalty-box-right"></div>
  </div>

  <div class="chat-container team-chat-container">
    <h3>Blue Team Chat &#128489;</h3>
    <div id="blueChatMessages" class="chat-messages"></div>
    <div class="chat-input-group team-chat-input-group">
      <input type="text" id="blueChatNameInput" placeholder="Your name" value="">
      <input type="text" id="blueChatMsgInput" placeholder="Message to Blue Team...">
      <button id="sendBlueChatBtn" onclick="sendTeamMessage('blue')">Send</button>
    </div>
  </div>
</div>

<div id="yellow" class="container" style="background:#fdd835aa; color:#000;">
  <h2>Yellow Team</h2>
  <div id="yellowPlayerManagement">
    <input type="text" id="yellowInput" placeholder="Enter player name">
    <button id="addYellowBtn" onclick="addYellow()">Add</button>
  </div>
  <ul id="yellowList"></ul>
  
  <div class="formation-controls">
    <button class="formation-btn" onclick="applyFormation('yellow', '4-3-3')">4-3-3</button>
    <button class="formation-btn" onclick="applyFormation('yellow', '4-4-2')">4-4-2</button>
    <button class="formation-btn" onclick="applyFormation('yellow', '3-4-3')">3-4-3</button>
    <button id="yellowDynamicBtn" class="dynamic-btn" onclick="applyDynamicPlan('yellow')">Apply Dynamic Plan</button>
  </div>
  
  <h3>Plan</h3>
  <div id="yellowPlan" class="field">
    <div class="mid-line"></div>
    <div class="center-circle"></div>
    <div class="penalty-box-left"></div>
    <div class="penalty-box-right"></div>
  </div>

  <div class="chat-container team-chat-container">
    <h3 style="color: #000;">Yellow Team Chat &#128489;</h3>
    <div id="yellowChatMessages" class="chat-messages"></div>
    <div class="chat-input-group team-chat-input-group">
      <input type="text" id="yellowChatNameInput" placeholder="Your name" value="">
      <input type="text" id="yellowChatMsgInput" placeholder="Message to Yellow Team...">
      <button id="sendYellowChatBtn" onclick="sendTeamMessage('yellow')">Send</button>
    </div>
  </div>
</div>

<div id="positionMenuOverlay" class="position-menu-overlay" style="display:none;">
    <div class="position-menu-box">
        <h3 id="positionMenuTitle">Select Position for Player Name</h3>
        <div id="positionMenuGrid" class="position-menu-grid">
            </div>
        <button onclick="closePositionMenu()" style="margin-top: 15px; background: #555;">Cancel</button>
    </div>
</div>

<div id="settingsModalOverlay" class="settings-modal-overlay">
    <div class="settings-modal-content">
        <div id="passwordSection">
            <h2>Admin Settings</h2>
            <div class="password-input-group">
                <input type="password" id="settingsPassword" placeholder="Password">
                <button onclick="authenticateSettings()" style="background: #d32f2f; color: #fff; width: 70%;">Enter</button>
                <p id="passwordError" style="color: #ffeb3b; display: none; margin: 5px 0;">Incorrect password.</p>
            </div>
        </div>

        <div id="settingsControls" style="display:none;">
            <h2>System Options</h2>
            <div class="setting-item">
                <label for="allowPlayerEdit">Allow Player Add/Edit/Delete (Main Lists)</label>
                <input type="checkbox" id="allowPlayerEdit">
            </div>
             <div class="setting-item">
                <label for="allowTeamEdit">Allow Player Add/Edit/Delete (Teams)</label>
                <input type="checkbox" id="allowTeamEdit">
            </div>
            <div class="setting-item">
                <label for="allowFormationEdit">Allow Applying Formations (Plan)</label>
                <input type="checkbox" id="allowFormationEdit">
            </div>
            <div class="setting-item">
                <label for="allowAddressEdit">Allow Editing Match Address</label>
                <input type="checkbox" id="allowAddressEdit">
            </div>
            <div class="setting-item">
                <label for="allowChat">Allow Sending Chat Messages</label>
                <input type="checkbox" id="allowChat">
            </div>
            <div class="setting-item">
                <label for="allowMusic">Allow Toggling Music</label>
                <input type="checkbox" id="allowMusic">
            </div>
            
            <div class="setting-item">
                <label for="enforceTimeRestriction">Enforce Time Restriction (Wed-Sun)</label>
                <input type="checkbox" id="enforceTimeRestriction">
            </div>
            <div class="setting-item">
                <label for="requireIndividualPin">Require Individual Player PIN (Main List)</label>
                <input type="checkbox" id="requireIndividualPin">
            </div>
            <div class="settings-footer">
                <button id="saveSettingsBtn" onclick="saveSettings()">Save & Close</button>
            </div>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script> 

<script>
// =========================================================================================
// ---- 1. GENERAL CONFIGURATION & DATA STRUCTURES ----
// =========================================================================================

// Supabase Configuration
const supabaseUrl = "https://wihhlvgkjglphjzhivdn.supabase.co"; // *** Replace your project URL here ***
const supabaseServiceKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndpaGhsdmdramdscGhqemhpdmRuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5NDMwOTYsImV4cCI6MjA3ODUxOTA5Nn0.0uG2yhtSzNiGfn3f1ZjB0p33lMh75Et28aMgMGznWlQ"; // *** Replace your Anon Public Key here ***
const supabase = window.supabase.createClient(supabaseUrl, supabaseServiceKey);

// Global state variables
let currentPositionTarget = { team: null, playerId: null, playerName: null };
const nameColors = ["#e53935", "#1e88e5", "#fbc02d","#43a047","#8e24aa","#fb8c00","#00acc1","#d81b60","#6d4c41","#3949ab","#f4511e","#7cb342"];
let audioInitialized = false; 

// NEW: System Configuration State (Defaults to all enabled)
let systemConfig = {
    allowPlayerEdit: true, // Main/Waiting lists (Add/Edit/Delete)
    allowTeamEdit: true, // Blue/Yellow lists (Add/Edit/Delete)
    allowFormationEdit: true, // Formations/Dynamic Plan/Dragging
    allowAddressEdit: true, // Match Address editing
    allowChat: true, // All chat sending
    allowMusic: true, // Audio button
    enforceTimeRestriction: true, // **** MODIFIED: Enforce Wed-Sun rule ****
    requireIndividualPin: true, // **** MODIFIED: Require Individual PIN for main list ****
};

// List of available positions
const POSITIONS_LIST = [
    { code: 'GK', label: 'Goalkeeper' },
    { code: 'CB', label: 'Center Back' },
    { code: 'RB', label: 'Right Back' },
    { code: 'LB', label: 'Left Back' },
    { code: 'DM', label: 'Defensive Midfielder' }, 
    { code: 'CM', label: 'Center Midfield' },
    { code: 'RM', label: 'Right Midfield' },
    { code: 'LM', label: 'Left Midfield' },
    { code: 'CAM', label: 'Attacking Mid' },
    { code: 'CF', label: 'Center Forward' }, 
    { code: 'RW', label: 'Right Winger' }, 
    { code: 'LW', label: 'Left Winger' }, 
    { code: 'ST', label: 'Striker' }, 
    { code: 'SUB', label: 'Substitute' }
];

// Formation Definitions (Coordinates are based on the field size of 400px x 250px)
const FORMATIONS = {
    '4-3-3': [
        { left: '5%', top: '50%', code: 'GK' },  
        { left: '20%', top: '25%', code: 'LB' }, 
        { left: '20%', top: '40%', code: 'CB' }, 
        { left: '20%', top: '60%', code: 'CB' }, 
        { left: '20%', top: '75%', code: 'RB' }, 
        
        { left: '50%', top: '35%', code: 'CM' }, 
        { left: '50%', top: '50%', code: 'DM' }, 
        { left: '50%', top: '65%', code: 'CM' }, 
        
        { left: '80%', top: '25%', code: 'LW' }, 
        { left: '80%', top: '50%', code: 'CF' }, 
        { left: '80%', top: '75%', code: 'RW' }, 
        
        { left: '40%', top: '5%', code: 'SUB' }, // Default sub position
    ],
    '4-4-2': [
        { left: '5%', top: '50%', code: 'GK' },  
        { left: '25%', top: '10%', code: 'LB' }, 
        { left: '25%', top: '35%', code: 'CB' }, 
        { left: '25%', top: '65%', code: 'CB' }, 
        { left: '25%', top: '90%', code: 'RB' }, 
        
        { left: '55%', top: '10%', code: 'LM' }, 
        { left: '55%', top: '35%', code: 'DM' }, 
        { left: '55%', top: '65%', code: 'CM' }, 
        { left: '55%', top: '90%', code: 'RM' }, 
        
        { left: '80%', top: '35%', code: 'CF' }, 
        { left: '80%', top: '65%', code: 'ST' }, 
        
        { left: '40%', top: '5%', code: 'SUB' }, 
    ],
    '3-4-3': [
        { left: '5%', top: '50%', code: 'GK' },  
        { left: '20%', top: '20%', code: 'CB' }, 
        { left: '20%', top: '50%', code: 'CB' }, 
        { left: '20%', top: '80%', code: 'CB' }, 
        
        { left: '45%', top: '10%', code: 'LM' }, 
        { left: '45%', top: '35%', code: 'DM' }, 
        { left: '45%', top: '65%', code: 'CM' }, 
        { left: '45%', top: '90%', code: 'RM' }, 
        
        { left: '75%', top: '25%', code: 'LW' }, 
        { left: '75%', top: '50%', code: 'CF' }, 
        { left: '75%', top: '75%', code: 'RW' }, 
        
        { left: '10%', top: '95%', code: 'SUB' }, 
    ]
};

// Utility function for consistent color generation
function stringToHash(str) {
  let hash = 0;
  if (str.length === 0) return hash;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash |= 0; 
  }
  return Math.abs(hash);
}

function getColorForUsername(username) {
    const hash = stringToHash(username.trim().toUpperCase());
    const index = hash % nameColors.length;
    return nameColors[index];
}

// =========================================================================================
// ---- 2. UI & AUDIO CONTROL (UPDATED) ----
// =========================================================================================

function showSection(id){
  document.querySelectorAll('.container').forEach(c=>c.style.display='none');
  document.getElementById(id).style.display='block';

  // Apply UI restrictions on section change
  applyUIRestrictions();

  if (id === 'blue') {
    loadTeamChatMessages('blue');
    document.getElementById('blueChatNameInput').value = localStorage.getItem('chat_username') || '';
    setupDraggable('blue'); 
  } else if (id === 'yellow') {
    loadTeamChatMessages('yellow');
    document.getElementById('yellowChatNameInput').value = localStorage.getItem('chat_username') || '';
    setupDraggable('yellow'); 
  } else if (id === 'main') {
    loadChatMessages();
  }
}
showSection('main'); // Initial load

function toggleBackgroundMusic() {
    if (!systemConfig.allowMusic) {
        alert("Audio control is currently disabled by the system administrator.");
        return;
    }
    const audio = document.getElementById('musicPlayer');
    const toggleBtn = document.getElementById('audioToggleBtn');
    
    if (audio.paused) {
        audio.play().then(() => {
            toggleBtn.innerHTML = 'Stop Audio'; 
        }).catch(e => {
            console.error("Autoplay failed for music player:", e);
        });
    } else {
        audio.pause();
        toggleBtn.innerHTML = 'Audio'; 
    }
}


// =========================================================================================
// ---- 3. SYSTEM SETTINGS CONTROL (MODIFIED) ----
// =========================================================================================

const ADMIN_PASSWORD = "2023"; // Admin password
// const PLAYER_PIN = "1234"; // No longer needed, PIN is per-player

function showSettingsModal() {
    document.getElementById('settingsPassword').value = '';
    document.getElementById('passwordError').style.display = 'none';
    document.getElementById('settingsControls').style.display = 'none';
    document.getElementById('passwordSection').style.display = 'block';
    document.getElementById('settingsModalOverlay').style.display = 'flex';
}

function authenticateSettings() {
    const passwordInput = document.getElementById('settingsPassword').value;
    const errorElement = document.getElementById('passwordError');
    
    if (passwordInput === ADMIN_PASSWORD) {
        errorElement.style.display = 'none';
        document.getElementById('passwordSection').style.display = 'none';
        document.getElementById('settingsControls').style.display = 'block';
        
        // Load current settings into checkboxes
        document.getElementById('allowPlayerEdit').checked = systemConfig.allowPlayerEdit;
        document.getElementById('allowTeamEdit').checked = systemConfig.allowTeamEdit;
        document.getElementById('allowFormationEdit').checked = systemConfig.allowFormationEdit;
        document.getElementById('allowAddressEdit').checked = systemConfig.allowAddressEdit;
        document.getElementById('allowChat').checked = systemConfig.allowChat;
        document.getElementById('allowMusic').checked = systemConfig.allowMusic;
        // **** MODIFIED: Load new settings ****
        document.getElementById('enforceTimeRestriction').checked = systemConfig.enforceTimeRestriction;
        document.getElementById('requireIndividualPin').checked = systemConfig.requireIndividualPin;

    } else {
        errorElement.style.display = 'block';
    }
}

async function saveSettings() {
    // Collect settings from checkboxes
    const newConfig = {
        allowPlayerEdit: document.getElementById('allowPlayerEdit').checked,
        allowTeamEdit: document.getElementById('allowTeamEdit').checked,
        allowFormationEdit: document.getElementById('allowFormationEdit').checked,
        allowAddressEdit: document.getElementById('allowAddressEdit').checked,
        allowChat: document.getElementById('allowChat').checked,
        allowMusic: document.getElementById('allowMusic').checked,
        // **** MODIFIED: Save new settings ****
        enforceTimeRestriction: document.getElementById('enforceTimeRestriction').checked,
        requireIndividualPin: document.getElementById('requireIndividualPin').checked,
    };
    
    // Save to Supabase (using id=1 config row)
    const { error } = await supabase
        .from('app_config')
        .update({ system_config: JSON.stringify(newConfig) })
        .eq('id', 1);

    if (error) {
        console.error('Error saving system config:', error);
        alert(`Failed to save settings: ${error.message}`);
        return;
    }
    
    // Update local state and apply restrictions
    systemConfig = newConfig;
    applyUIRestrictions();
    
    // Close modal
    document.getElementById('settingsModalOverlay').style.display = 'none';
    
    alert('System settings saved successfully!');
}

// **** NEW: Helper function to verify a player's individual PIN ****
async function verifyIndividualPin(table, id) {
    // 1. Get the stored PIN for this player
    const { data, error } = await supabase
        .from(table)
        .select('player_pin')
        .eq('id', id)
        .single();
    
    if (error || !data) {
        console.error("Could not find player to verify PIN:", error);
        alert("Error finding player data.");
        return false;
    }

    const storedPin = data.player_pin;

    // 2. If player has no PIN (e.g., old player), allow action
    if (!storedPin) {
        console.log("No PIN found for this player. Allowing action.");
        return true; 
    }

    // 3. Player has a PIN, so we must ask for it
    const enteredPin = prompt("Enter your 4-digit PIN to confirm this action:");
    
    if (enteredPin === null) {
        alert("Operation cancelled.");
        return false;
    }
    
    if (enteredPin === storedPin) {
        return true;
    } else {
        alert("Incorrect PIN. Operation cancelled.");
        return false;
    }
}


async function loadSystemConfig() {
    const { data } = await supabase.from('app_config').select('system_config').eq('id', 1).single(); 
    
    if (data && data.system_config) {
        try {
            const loadedConfig = JSON.parse(data.system_config);
            systemConfig = { ...systemConfig, ...loadedConfig }; 
        } catch (e) {
            console.error("Error parsing system config from database:", e);
        }
    }
    applyUIRestrictions(); // Apply immediately after loading
}

function applyUIRestrictions() {
    // 1. Player Management (Main/Waiting Lists)
    const playerManagement = document.getElementById('playerManagement');
    playerManagement.style.display = systemConfig.allowPlayerEdit ? 'block' : 'none';
    
    // 2. Player Action Buttons (Edit/Delete)
    document.querySelectorAll('.action-btn').forEach(btn => {
        const isTeamBtn = btn.parentNode.parentNode.id === 'blueList' || btn.parentNode.parentNode.id === 'yellowList';
        if (isTeamBtn) {
            btn.style.display = systemConfig.allowTeamEdit ? 'inline-block' : 'none';
        } else {
            btn.style.display = systemConfig.allowPlayerEdit ? 'inline-block' : 'none';
        }
    });

    // 3. Team Player Management (Blue/Yellow Add Buttons)
    document.getElementById('bluePlayerManagement').style.display = systemConfig.allowTeamEdit ? 'block' : 'none';
    document.getElementById('yellowPlayerManagement').style.display = systemConfig.allowTeamEdit ? 'block' : 'none';
    
    // 4. Formation Controls
    const displayFormation = systemConfig.allowFormationEdit ? 'inline-block' : 'none';
    document.querySelectorAll('.formation-btn, .dynamic-btn').forEach(btn => {
        btn.style.display = displayFormation;
    });
    
    // 5. Address Edit (Double-click listener is controlled by a flag)
    // The actual control is handled within the event listener/saveMatchAddress functions now.
    
    // 6. Chat Controls
    const chatControls = systemConfig.allowChat ? 'flex' : 'none';
    document.querySelector('.chat-container .chat-input-group').style.display = chatControls;
    document.querySelector('.team-chat-container #blueChatMessages + .chat-input-group').style.display = chatControls;
    document.querySelector('.team-chat-container #yellowChatMessages + .chat-input-group').style.display = chatControls;
    
    // 7. Music Control
    // The function toggleBackgroundMusic already checks systemConfig.allowMusic
}

// =========================================================================================
// ---- 4. TIME & WEEKLY CLEANUP (MODIFIED) ----
// =========================================================================================

function isWithinAllowedTime(){
    // **** MODIFIED: Check admin setting first ****
    if (!systemConfig.enforceTimeRestriction) {
        return true;
    }

    // Original time logic
    const now = new Date();
    const currentDay = now.getDay(); 
    const currentHour = now.getHours(); 
    const currentMinute = now.getMinutes();

    // From Wednesday (3) 3 PM to Sunday (0) 12 PM
    if (currentDay >= 3 && currentDay <= 6) { 
        if (currentDay === 3) {
            return currentHour >= 15;
        }
        return true; 
    } else if (currentDay === 0) {
        if (currentHour < 12) {
            return true;
        } else if (currentHour === 12 && currentMinute === 0) {
            return true;
        }
        return false; 
    }
    return false;
}

function formatPlayerTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    return date.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit',
        hour12: true,
        numberingSystem: 'latn' 
    });
}

// Check and clear data every Sunday after 6 PM
async function checkAndClearData() {
    const now = new Date();
    let cleanupTimepoint = new Date(now);
    const currentDay = now.getDay(); 
    const currentHour = now.getHours();
    
    // Set cleanup time to last Sunday, 6 PM
    cleanupTimepoint.setDate(now.getDate() - currentDay);
    cleanupTimepoint.setHours(18, 0, 0, 0); 
    
    if (currentDay === 0 && currentHour < 18) {
        cleanupTimepoint.setDate(cleanupTimepoint.getDate() - 7);
    } 
    
    const lastCleanupTimestamp = localStorage.getItem('last_cleanup_timestamp');
    let lastCleanupDate = lastCleanupTimestamp ? new Date(parseInt(lastCleanupTimestamp)) : new Date(0);

    if (cleanupTimepoint.getTime() > lastCleanupDate.getTime()) {
        console.log("Weekly cleanup required. Clearing data..."); 

        const tablesToClear = ["main_team", "waiting_list", "blue_team", "yellow_team", "chat_messages", "blue_chat", "yellow_chat"];
        
        await Promise.all(tablesToClear.map(table => {
            const deleteQuery = supabase.from(table).delete().neq('id', 0);
            return deleteQuery
                .then(() => console.log(`Table ${table} cleared.`)) 
                .catch(error => console.error(`Error clearing table ${table}:`, error)); 
        }));
        
        // Ensure app_config row is preserved or reset its modifiable data
        const defaultMatchAddress = "Click here to set match address"; 
        const { error: configError } = await supabase
            .from('app_config')
            .update({ match_address: defaultMatchAddress })
            .eq('id', 1);
        if (configError) console.error("Error resetting match address:", configError.message);

        localStorage.setItem('last_cleanup_timestamp', now.getTime().toString());
        console.log("Cleanup complete. Timestamp updated."); 
        
        loadPlayers();
        loadBlue();
        loadYellow();
        loadChatMessages();
        loadTeamChatMessages('blue');
        loadTeamChatMessages('yellow');
        loadMatchAddress();
    } 
}


// =========================================================================================
// ---- 5. MAIN & WAITING LISTS MANAGEMENT (MODIFIED) ----
// =========================================================================================

async function addPlayer(){
  if(!systemConfig.allowPlayerEdit){
    alert("Player addition is currently disabled by the system administrator.");
    return;
  }
  if(!isWithinAllowedTime()){
    alert("Adding players is only allowed from Wednesday 3 PM to Sunday 12 PM.");
    return;
  }
  const name = document.getElementById("nameInput").value.trim();
  if(!name) return alert("Enter a name");
  
  let newPin = null;
  // **** MODIFIED: Ask to CREATE a PIN if required ****
  if (systemConfig.requireIndividualPin) {
      const pin1 = prompt("Create your 4-digit PIN (you will need this to edit/delete your name):");
      
      // Basic validation
      if (!pin1 || pin1.length !== 4 || isNaN(pin1)) {
          alert("Invalid PIN. Must be 4 numbers. Operation cancelled.");
          return;
      }
      
      const pin2 = prompt("Confirm your 4-digit PIN:");
      
      if (pin1 !== pin2) {
          alert("PINs do not match. Operation cancelled.");
          return;
      }
      newPin = pin1; // PIN is confirmed
  }
  // **** END OF MODIFICATION ****

  const { data: team } = await supabase.from("main_team").select("id");
  
  const playerData = { name, time: Date.now() };
  if (newPin) {
      playerData.player_pin = newPin; // Add PIN to the data object
  }

  if(team.length < 24){
    const { error } = await supabase.from("main_team").insert([playerData]);
    if(error) return alert(error.message);
    
    const message = `Player ${name} joined the Main Team!`; 
    await sendSystemMessageToChat(name, message);

  } else {
    const { error } = await supabase.from("waiting_list").insert([playerData]);
    
    if(error) {
        return alert("Main team is full (24). Player could not be added to waiting list."); 
    }
    
    alert("The Main Team is full (24 players). You have been added to the Waiting List.");
    
    const systemMessage = `Player ${name} was added to the Waiting List because the main team is full.`; 
    await sendSystemMessageToChat(name, systemMessage);
  }
  
  document.getElementById("nameInput").value="";
  loadPlayers();
}

async function loadPlayers(){
  const { data: team } = await supabase.from("main_team").select("*").order("id");
  const { data: waiting } = await supabase.from("waiting_list").select("*").order("id");
  const teamList = document.getElementById("teamList");
  const waitingList = document.getElementById("waitingList");
  teamList.innerHTML = "";
  waitingList.innerHTML = "";
  
  const isPlayerEditAllowed = systemConfig.allowPlayerEdit;

  if(team) team.forEach((p,i) => {
    const time = formatPlayerTime(p.time); 
    const buttons = isPlayerEditAllowed ? 
        `<span>
          <button class="action-btn edit-btn" onclick="editPlayer('main_team',${p.id},'${p.name}')">Edit</button> 
          <button class="action-btn delete-btn" onclick="deletePlayer('main_team',${p.id})">Delete</button>
        </span>` : '';
    teamList.innerHTML += `
      <li>
        <div class="player-info">
            <span>${i+1}. ${p.name} <span class="player-time">${time}</span></span>
        </div>
        ${buttons}
      </li>`;
  });

  if(waiting) waiting.forEach((p,i) => {
    const time = formatPlayerTime(p.time); 
    const buttons = isPlayerEditAllowed ? 
        `<span>
          <button class="action-btn edit-btn" onclick="editPlayer('waiting_list',${p.id},'${p.name}')">Edit</button>
          <button class="action-btn delete-btn" onclick="deletePlayer('waiting_list',${p.id})">Delete</button>
        </span>` : '';
    waitingList.innerHTML += `
      <li>
        <div class="player-info">
            <span>${i+1}. ${p.name} <span class="player-time">${time}</span></span>
        </div>
        ${buttons}
      </li>`;
  });
}

async function refillMainTeam(){
  const { data: team } = await supabase.from("main_team").select("id");
  const { data: waiting } = await supabase.from("waiting_list").select("*").order("id", { ascending: true }); // Ensure order is correct
  
  if(team.length < 24 && waiting.length > 0){
    const first = waiting[0];
    
    // 1. Prepare to add the player to the main team (with their PIN)
    const addPromise = supabase.from("main_team").insert([{ 
        name: first.name, 
        time: Date.now(), 
        player_pin: first.player_pin // Transfer the PIN
    }]);
    
    // 2. Prepare to delete the player from the waiting list
    const deletePromise = supabase.from("waiting_list").delete().eq("id", first.id);
    
    // 3. Execute both promises simultaneously
    const [addResult, deleteResult] = await Promise.all([addPromise, deletePromise]);
    
    if(addResult.error) {
        console.error("Error adding player from waiting list to main team:", addResult.error);
        return; 
    }
    
    if(deleteResult.error) {
        console.error("Error deleting player from waiting list:", deleteResult.error);
    }
    
    const message = `Player ${first.name} moved from Waiting List to Main Team.`;
    await sendSystemMessageToChat(first.name, message);
  }
}

async function deletePlayer(table,id){
  let playerName = "";
  let isMainTeam = table === "main_team";
  let isMainOrWaiting = isMainTeam || table === "waiting_list"; // Helper variable
  
  // New restriction check
  const isTeamTable = table === "blue_team" || table === "yellow_team";
  if (isMainOrWaiting && !systemConfig.allowPlayerEdit) {
      alert("Player deletion from main/waiting lists is currently disabled by the system administrator.");
      return;
  }
  if (isTeamTable && !systemConfig.allowTeamEdit) {
      alert("Player deletion from team lists is currently disabled by the system administrator.");
      return;
  }

  // **** MODIFIED: Check individual PIN if required ****
  if (isMainOrWaiting && systemConfig.requireIndividualPin) { 
      const pinVerified = await verifyIndividualPin(table, id);
      if (!pinVerified) {
          return; // Stop if PIN is required and fails
      }
  }
  // **** END OF MODIFICATION ****

  // Retrieve name *before* deletion for system message
  const { data, error } = await supabase.from(table).select('name').eq("id", id).single();
  if (data) {
      playerName = data.name;
  } else {
      console.error("Could not retrieve player name before deletion:", error);
  }

  if(!confirm("Are you sure you want to delete this player?")) return;
  
  if (isMainTeam && playerName) {
      const message = `Player ${playerName} left the Main Team.`; 
      await sendSystemMessageToChat(playerName, message);
  }

  await supabase.from(table).delete().eq("id",id);
  
  if(table==="main_team") {
    await refillMainTeam(); 
  }
  
  reloadList(table);
}

async function editPlayer(table,id,oldName){
  // New restriction check
  const isMainOrWaiting = table === "main_team" || table === "waiting_list";
  if (isMainOrWaiting && !systemConfig.allowPlayerEdit) {
      alert("Player editing in main/waiting lists is currently disabled by the system administrator.");
      return;
  }
  if (!isMainOrWaiting && !systemConfig.allowTeamEdit) {
      alert("Player editing in team lists is currently disabled by the system administrator.");
      return;
  }
  
  // **** MODIFIED: Check individual PIN if required ****
  if (isMainOrWaiting && systemConfig.requireIndividualPin) { 
      const pinVerified = await verifyIndividualPin(table, id);
      if (!pinVerified) {
          return; // Stop if PIN is required and fails
      }
  }
  // **** END OF MODIFICATION ****

  const newName=prompt("Edit name:", oldName);
  if(!newName || newName.trim()==="") return;
  // We only update the name, the PIN stays the same
  await supabase.from(table).update({name:newName.trim()}).eq("id",id); 
  reloadList(table);
}

function reloadList(table){
  if(table==="main_team" || table==="waiting_list") loadPlayers();
  else if(table==="blue_team") loadBlue();
  else if(table==="yellow_team") loadYellow();
  applyUIRestrictions(); // Re-apply restrictions after list reload (important for buttons)
}

// =========================================================================================
// ---- 6. BLUE/YELLOW TEAM MANAGEMENT & LOADING ----
// =========================================================================================

async function addBlue(){
  if(!systemConfig.allowTeamEdit){
    alert("Player addition to teams is currently disabled by the system administrator.");
    return;
  }
  const name=document.getElementById("blueInput").value.trim();
  if(!name) return;
  const { data: team } = await supabase.from("blue_team").select("id");
  if(team.length >= 12) return alert("Blue team is full (12 players).");
  
  const defaultPos = FORMATIONS['4-3-3'][0];
  const positionString = JSON.stringify({ left: defaultPos.left, top: defaultPos.top });
  await supabase.from("blue_team").insert([{name, time: Date.now(), position: positionString, position_code: defaultPos.code }]);

  document.getElementById("blueInput").value="";
  loadBlue();
}

async function loadBlue(){
  const { data } = await supabase.from("blue_team").select("*").order("id");
  const ul=document.getElementById("blueList");
  const field=document.getElementById("bluePlan");
  ul.innerHTML=""; 
  // Clear field but keep base markings
  field.innerHTML=`<div class="mid-line"></div><div class="center-circle"></div><div class="penalty-box-left"></div><div class="penalty-box-right"></div>`; 
  
  const isTeamEditAllowed = systemConfig.allowTeamEdit;
  
  if(data) data.forEach((p,i)=>{
    const time = formatPlayerTime(p.time); 
    const buttons = isTeamEditAllowed ?
        `<span>
          <button class="action-btn edit-btn" onclick="editPlayer('blue_team',${p.id},'${p.name}')">Edit</button>
          <button class="action-btn delete-btn" onclick="deletePlayer('blue_team',${p.id})">Delete</button>
        </span>` : '';
    ul.innerHTML += `
      <li>
        <div class="player-info">
            <span>${i+1}. ${p.name} <span class="player-time">${time}</span></span>
        </div>
        ${buttons}
      </li>`;
    let pos = p.position ? JSON.parse(p.position) : null;
    createPlayerMarker('blue', p.name, p.id, pos, p.position_code, i + 1);
  });
  setupDraggable('blue');
}

async function addYellow(){
  if(!systemConfig.allowTeamEdit){
    alert("Player addition to teams is currently disabled by the system administrator.");
    return;
  }
  const name=document.getElementById("yellowInput").value.trim();
  if(!name) return;
  const { data: team } = await supabase.from("yellow_team").select("id");
  if(team.length >= 12) return alert("Yellow team is full (12 players).");
  
  const defaultPos = FORMATIONS['4-3-3'][0];
  const positionString = JSON.stringify({ left: defaultPos.left, top: defaultPos.top });
  await supabase.from("yellow_team").insert([{name, time: Date.now(), position: positionString, position_code: defaultPos.code }]);

  document.getElementById("yellowInput").value="";
  loadYellow();
}

async function loadYellow(){
  const { data } = await supabase.from("yellow_team").select("*").order("id");
  const ul=document.getElementById("yellowList");
  const field=document.getElementById("yellowPlan");
  ul.innerHTML=""; 
  field.innerHTML=`<div class="mid-line"></div><div class="center-circle"></div><div class="penalty-box-left"></div><div class="penalty-box-right"></div>`; 
  
  const isTeamEditAllowed = systemConfig.allowTeamEdit;
  
  if(data) data.forEach((p,i)=>{
    const time = formatPlayerTime(p.time); 
    const buttons = isTeamEditAllowed ?
        `<span>
          <button class="action-btn edit-btn" onclick="editPlayer('yellow_team',${p.id},'${p.name}')">Edit</button>
          <button class="action-btn delete-btn" onclick="deletePlayer('yellow_team',${p.id})">Delete</button>
        </span>` : '';
    ul.innerHTML += `
      <li>
        <div class="player-info">
            <span>${i+1}. ${p.name} <span class="player-time">${time}</span></span>
        </div>
        ${buttons}
      </li>`;
    let pos = p.position ? JSON.parse(p.position) : null;
    createPlayerMarker('yellow', p.name, p.id, pos, p.position_code, i + 1);
  });
  setupDraggable('yellow');
}

// =========================================================================================
// ---- 7. FORMATIONS & TACTICS ----
// =========================================================================================

async function applyFormation(team, formationName) {
    if(!systemConfig.allowFormationEdit){
        alert("Formation controls are currently disabled by the system administrator.");
        return;
    }

    const table = team === 'blue' ? 'blue_team' : 'yellow_team';
    const formation = FORMATIONS[formationName];
    
    const { data: players, error } = await supabase.from(table).select('id').order('id', { ascending: true });
    
    if (error || !players || players.length === 0) {
        alert(`No players found in the ${team} team to apply formation.`);
        return;
    }

    const updates = players.slice(0, 12).map((player, index) => {
        let pos;
        if (index < formation.length) {
            pos = formation[index];
        } else {
            pos = { left: '40%', top: '5%', code: 'SUB' };
        }

        const positionString = JSON.stringify({ 
            left: pos.left, 
            top: pos.top 
        });
        
        return supabase.from(table)
            .update({ 
                position: positionString,
                position_code: pos.code 
            })
            .eq('id', player.id)
            .select(); 
    });

    await Promise.all(updates);
    
    if (team === 'blue') loadBlue(); else loadYellow();
    alert(`${formationName} formation applied successfully to the ${team} team.`);
}

// Dynamic Formation Logic based on number of players (N)
function getDynamicFormation(N) {
    if (N === 0) return [];

    const distributionMap = [];
    distributionMap.push({ X: 5, Y_count: 1, code: 'GK' }); // 1 Player
    distributionMap.push({ X: 25, Y_count: 4, code: 'CB' }); // Up to 4 players
    distributionMap.push({ X: 55, Y_count: 4, code: 'CM' }); // Up to 4 players
    distributionMap.push({ X: 80, Y_count: 3, code: 'CF' }); // Up to 3 players
    
    if (N > 12) {
        distributionMap.push({ X: 10, Y_count: N - 12, code: 'SUB' }); 
    }

    const positions = [];
    let currentPlayerIndex = 1;

    for (const zone of distributionMap) {
        if (currentPlayerIndex > N) break;

        let playersInZone = Math.min(zone.Y_count, N - currentPlayerIndex + 1);
        if (playersInZone === 0) continue;
        
        const Y_min = 10;
        const Y_max = 90;
        let deltaY = playersInZone > 1 ? (Y_max - Y_min) / (playersInZone - 1) : 0;

        for (let j = 0; j < playersInZone; j++) {
            let top;
            if (playersInZone === 1) {
                top = 50; 
            } else {
                top = Y_min + j * deltaY;
            }

            positions.push({
                left: `${zone.X}%`,
                top: `${top.toFixed(2)}%`,
                code: zone.code 
            });

            currentPlayerIndex++;
        }
    }
    return positions;
}

async function applyDynamicPlan(team) {
    if(!systemConfig.allowFormationEdit){
        alert("Dynamic plan control is currently disabled by the system administrator.");
        return;
    }
    
    const table = team === 'blue' ? 'blue_team' : 'yellow_team';
    
    const { data: players, error } = await supabase.from(table).select('id').order('id', { ascending: true });
    
    if (error || !players || players.length === 0) {
        alert(`No players found in the ${team} team to apply the dynamic plan.`);
        return;
    }
    
    const N = players.length;
    const dynamicFormation = getDynamicFormation(N);
    
    const updates = players.map((player, index) => {
        if (index < dynamicFormation.length) {
            const pos = dynamicFormation[index];
            const positionString = JSON.stringify({ 
                left: pos.left, 
                top: pos.top 
            });
            return supabase.from(table)
                .update({ 
                    position: positionString,
                    position_code: pos.code 
                })
                .eq('id', player.id)
                .select();
        }
        return null; 
    }).filter(update => update !== null); 

    await Promise.all(updates);
    
    if (team === 'blue') loadBlue(); else loadYellow();
    alert(`Dynamic plan applied successfully for ${N} players in the ${team} team.`);
}

// =========================================================================================
// ---- 8. PLAYER MARKERS & DRAGGING (InteractJS) ----
// =========================================================================================

function distance(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
}

function getNearestPositionCode(newLeftPercent, newTopPercent) {
    const referenceFormation = FORMATIONS['4-3-3'].concat(
        FORMATIONS['4-4-2'].filter(p => !FORMATIONS['4-3-3'].some(fp => fp.code === p.code))
    ).concat(
        FORMATIONS['3-4-3'].filter(p => !FORMATIONS['4-3-3'].some(fp => fp.code === p.code) && !FORMATIONS['4-4-2'].some(fp => fp.code === p.code))
    );
    
    let nearestCode = 'SUB';
    let minDistance = Infinity;

    referenceFormation.forEach(pos => {
        const refLeft = parseFloat(pos.left);
        const refTop = parseFloat(pos.top);
        const dist = distance(newLeftPercent, newTopPercent, refLeft, refTop);

        if (dist < minDistance) {
            minDistance = dist;
            nearestCode = pos.code;
        }
    });

    return nearestCode;
}

function createPlayerMarker(team, playerName, playerId, storedPosition=null, positionCode='SUB', playerNumber=null) { 
  const fieldId = team === 'blue' ? 'bluePlan' : 'yellowPlan';
  const field = document.getElementById(fieldId);

  const existingMarker = document.getElementById(`marker-${team}-${playerId}`);
  if (existingMarker) existingMarker.remove();

  const marker = document.createElement('div');
  marker.classList.add('player-marker');
  marker.id = `marker-${team}-${playerId}`; 
  marker.dataset.playerId = playerId;
  marker.dataset.team = team;
  marker.dataset.table = team === 'blue' ? 'blue_team' : 'yellow_team';
  marker.style.background = team==='blue'? '#1976d2' : '#fbc02d';
  
  const displayPlayerName = playerNumber !== null ? `${playerNumber}. ${playerName}` : playerName;
  
  let leftPercent = '50%';
  let topPercent = '50%';
  
  if (storedPosition) {
    leftPercent = storedPosition.left;
    topPercent = storedPosition.top;
  }

  marker.style.left = leftPercent;
  marker.style.top = topPercent;

  marker.innerHTML = `<span class="player-position-label">${positionCode || 'SUB'}</span>`;

  const label = document.createElement('div');
  label.classList.add('player-name');
  label.innerText = displayPlayerName; 
  label.style.color = team==='blue' ? '#fff' : '#000'; 
  marker.appendChild(label);
  
  // ADD CLICK LISTENER FOR POSITION SELECTION
  if (systemConfig.allowFormationEdit) {
      marker.addEventListener('click', (e) => {
        if (e.detail === 1) { 
            showPositionMenu(team, playerId, playerName);
        }
      });
  }

  field.appendChild(marker);
}


function setupDraggable(team) {
  const fieldId = team === 'blue' ? '#bluePlan' : '#yellowPlan';
  const table = team === 'blue' ? 'blue_team' : 'yellow_team';
  const field = document.getElementById(team === 'blue' ? 'bluePlan' : 'yellowPlan');

  // Unset all existing interact handlers for this selector to prevent duplicates
  interact(`${fieldId} .player-marker`).unset(); 

  // Only setup dragging if allowed
  if (!systemConfig.allowFormationEdit) return;

  interact(`${fieldId} .player-marker`)
    .draggable({
      inertia: false, 
      
      modifiers: [
        interact.modifiers.restrictRect({
          restriction: field, 
        })
      ],
      listeners: {
        start (event) {
            const target = event.target;
            const fieldRect = field.getBoundingClientRect();
            
            let left_percent = parseFloat(target.style.left);
            let top_percent = parseFloat(target.style.top);
            
            let x = (left_percent / 100) * fieldRect.width;
            let y = (top_percent / 100) * fieldRect.height;

            target.dataset.x = x;
            target.dataset.y = y;

            // Switch to pixel coordinates for smooth dragging
            target.style.left = `${x}px`;
            target.style.top = `${y}px`;
            target.style.transform = `translate(-50%, -50%)`;
            
        },
        
        move (event) {
          const target = event.target;
          
          let x = (parseFloat(target.dataset.x) || 0) + event.dx;
          let y = (parseFloat(target.dataset.y) || 0) + event.dy;

          target.style.left = `${x}px`;
          target.style.top = `${y}px`;

          target.dataset.x = x;
          target.dataset.y = y;

          // Update position code label on the fly
          const fieldRect = field.getBoundingClientRect();
          let left_percent = (x / fieldRect.width) * 100;
          let top_percent = (y / fieldRect.height) * 100;
          
          left_percent = Math.max(0, Math.min(100, left_percent));
          top_percent = Math.max(0, Math.min(100, top_percent));

          const newPositionCode = getNearestPositionCode(left_percent, top_percent);
          const labelElement = target.querySelector('.player-position-label');
          if (labelElement && labelElement.textContent !== newPositionCode) {
              labelElement.textContent = newPositionCode;
          }

        },
        
        end (event) {
          const target = event.target;
          const fieldRect = field.getBoundingClientRect();

          const x_end_px = parseFloat(target.dataset.x);
          const y_end_px = parseFloat(target.dataset.y);
          
          let left_percent = (x_end_px / fieldRect.width) * 100;
          let top_percent = (y_end_px / fieldRect.height) * 100;

          left_percent = Math.max(0, Math.min(100, left_percent));
          top_percent = Math.max(0, Math.min(100, top_percent));

          const newPositionCode = getNearestPositionCode(left_percent, top_percent);
          
          // Final DOM update
          const labelElement = target.querySelector('.player-position-label');
          if (labelElement) {
              labelElement.textContent = newPositionCode;
          }

          // Switch back to percentage coordinates
          target.style.left = `${left_percent.toFixed(2)}%`;
          target.style.top = `${top_percent.toFixed(2)}%`;
          target.style.transform = `translate(-50%, -50%)`;

          target.dataset.x = 0; 
          target.dataset.y = 0; 

          // Save to Supabase
          const playerId = target.dataset.playerId;
          const newPosition = JSON.stringify({ 
              left: `${left_percent.toFixed(2)}%`,
              top: `${top_percent.toFixed(2)}%`
          });
          
          supabase.from(table)
              .update({ 
                  position: newPosition,
                  position_code: newPositionCode 
              })
              .eq('id', playerId)
              .then(({ error }) => {
                  if (error) console.error("Error saving drag position:", error);
              });
        }
      }
    });
}


// =========================================================================================
// ---- 9. POSITION SELECTION MENU ----
// =========================================================================================

function showPositionMenu(team, playerId, playerName) {
    if (!systemConfig.allowFormationEdit) {
        alert("Position selection is currently disabled by the system administrator.");
        return;
    }
    
    currentPositionTarget = { team, playerId, playerName };
    document.getElementById('positionMenuTitle').textContent = `Select Position for ${playerName}`;
    
    const grid = document.getElementById('positionMenuGrid');
    grid.innerHTML = ''; 

    POSITIONS_LIST.forEach(pos => {
        const button = document.createElement('button');
        button.textContent = `${pos.code} (${pos.label})`;
        button.onclick = () => selectPosition(pos.code);
        grid.appendChild(button);
    });

    document.getElementById('positionMenuOverlay').style.display = 'flex';
}

async function closePositionMenu() {
    document.getElementById('positionMenuOverlay').style.display = 'none';
    currentPositionTarget = { team: null, playerId: null, playerName: null }; 
}

async function selectPosition(positionCode) {
    if (!systemConfig.allowFormationEdit) {
        closePositionMenu();
        return;
    }

    const { team, playerId } = currentPositionTarget;
    if (!team || !playerId) {
        closePositionMenu();
        return;
    }

    const table = team === 'blue' ? 'blue_team' : 'yellow_team';
    
    // Find a reference position (default to 50/50 if not found in formations)
    const refPos = FORMATIONS['4-3-3'].find(p => p.code === positionCode) || 
                   FORMATIONS['4-4-2'].find(p => p.code === positionCode) ||
                   FORMATIONS['3-4-3'].find(p => p.code === positionCode) ||
                   { left: '50%', top: '50%', code: positionCode };
    
    const newPosition = { left: refPos.left, top: refPos.top };

    const { error } = await supabase.from(table)
        .update({ 
            position_code: positionCode, 
            position: JSON.stringify(newPosition) 
        })
        .eq('id', playerId);

    if (error) {
        console.error('Error updating position:', error);
        alert(`Failed to update position: ${error.message}`);
    }

    closePositionMenu();
    reloadList(table);
}


// =========================================================================================
// ---- 10. ADDRESS, CHAT, HISTORY, REALTIME ----
// =========================================================================================

const addressDisplayElem = document.getElementById('addressDisplay');
async function loadMatchAddress() {
    const { data } = await supabase.from('app_config').select('match_address').eq('id', 1).single(); 
    const savedAddress = data ? data.match_address : null;

    if (savedAddress && savedAddress.trim() !== '') {
        addressDisplayElem.textContent = savedAddress;
    } else {
        addressDisplayElem.textContent = "Click here to set match address";
    }
}
async function saveMatchAddress(address) {
    if (!systemConfig.allowAddressEdit) {
        alert("Match address editing is currently disabled by the system administrator.");
        loadMatchAddress(); // Revert display to current saved value
        return;
    }

    const defaultText = "Click here to set match address";
    const addressToSave = address.trim() || '';
    
    const { data: updateData, error: updateError } = await supabase
        .from('app_config')
        .update({ match_address: addressToSave })
        .eq('id', 1) 
        .select();

    if (updateError) { console.error("Error during UPDATE attempt:", updateError.message); }
    
    if (!updateData || updateData.length === 0) {
        const { error: insertError } = await supabase
            .from('app_config')
            .insert([{ id: 1, match_address: addressToSave }]);
            
        if (insertError) {
            console.error("Error during INSERT attempt:", insertError.message);
            return;
        }
    }
    
    document.getElementById('addressDisplay').textContent = addressToSave || defaultText;
}

// Global variable to hold the address editor handler
let addressDoubleClickHandler = null;

function setupAddressEditor() {
    // Remove previous listener if it exists
    if (addressDoubleClickHandler) {
        addressDisplayElem.removeEventListener('dblclick', addressDoubleClickHandler, false);
    }

    addressDoubleClickHandler = function() {
        if (!systemConfig.allowAddressEdit) {
            alert("Match address editing is currently disabled by the system administrator.");
            return;
        }
        
        const currentText = addressDisplayElem.textContent.includes("Click here") ? "" : addressDisplayElem.textContent.trim();
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentText;
        input.style.cssText = 'padding: 5px; width: 80%; border-radius: 5px; border: 1px solid #9c27b0; margin: 0; background: #2c2c2c; color: #fff; text-align: center; font-family: "Cairo", sans-serif; font-size: 16px; font-weight: bold;';
        addressDisplayElem.replaceWith(input);
        input.focus();
        
        const saveAndReplace = async () => {
            if (input.parentNode === null) return; 
            const newAddress = input.value;
            const p = document.createElement('p');
            p.id = 'addressDisplay';
            p.style.cssText = 'margin:5px 0; font-weight:bold; cursor:pointer; color:#9c27b0;'; 
            input.replaceWith(p); 
            await saveMatchAddress(newAddress); 
            p.addEventListener('dblclick', addressDoubleClickHandler, false); // Re-add the listener
        };
        
        input.addEventListener('blur', saveAndReplace, { once: true });
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); 
                input.removeEventListener('blur', saveAndReplace, { once: true }); 
                saveAndReplace();
            }
        });
    };

    addressDisplayElem.addEventListener('dblclick', addressDoubleClickHandler, false);
}


function playNotificationSound() {
    const sound = document.getElementById('notification-sound');
    sound.currentTime = 0; 
    sound.play().catch(e => console.log("Notification sound blocked:", e));
}

async function sendSystemMessageToChat(playerName, content) {
    const systemUsername = `System-Alert-(${playerName})`; 
    const { error } = await supabase
        .from('chat_messages')
        .insert([{ username: systemUsername, content }]); 
    
    if (error) {
        console.error('Error sending system message:', error);
    }
}

function renderMessage(message, containerId) {
  const messagesContainer = document.getElementById(containerId);
  if (!messagesContainer) return;

  const msgDiv = document.createElement('div');
  msgDiv.classList.add('message');
  
  const storedName = localStorage.getItem('chat_username');
  const isMyMessage = storedName && storedName.trim() === message.username.trim();
  const nameColor = getColorForUsername(message.username);

  if (isMyMessage) {
    msgDiv.classList.add('my-message');
  } else {
    msgDiv.style.borderColor = nameColor;
    msgDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.05)'; 
  }

  const date = new Date(message.created_at).toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: true, 
    numberingSystem: 'latn' 
  });
  
  const timeSpan = `<span style="color:#888;">${date}</span>`;
  
  if (message.username.startsWith('System-Alert-(')) {
      return; 
  }

  msgDiv.innerHTML = `
    <span class="message-header" style="color: ${nameColor};">${message.username} ${timeSpan}</span>
    <span>${message.content}</span>
  `;
  
  messagesContainer.appendChild(msgDiv); 
  messagesContainer.scrollTop = messagesContainer.scrollHeight; 
}

async function loadChatMessages() {
  const { data, error } = await supabase
    .from('chat_messages')
    .select('*')
    .not('username', 'like', 'System-Alert-%')
    .order('created_at', { ascending: true }) 
    .limit(50); 

  if (error) {
    console.error('Error loading chat messages:', error);
    return;
  }

  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.innerHTML = ''; 
  data.forEach(msg => renderMessage(msg, 'chatMessages'));
  
  messagesContainer.scrollTop = messagesContainer.scrollHeight; 
}

async function sendMessage() {
  if (!systemConfig.allowChat) {
    alert("Sending messages is currently disabled by the system administrator.");
    return;
  }
  
  const nameInput = document.getElementById('chatNameInput');
  const msgInput = document.getElementById('chatMsgInput');
  
  const username = nameInput.value.trim();
  const content = msgInput.value.trim();

  if (!username) { return alert("Please enter your name."); }
  if (!content) { return alert("Cannot send an empty message."); }

  localStorage.setItem('chat_username', username);

  const { error } = await supabase
    .from('chat_messages')
    .insert([{ username, content }]); 

  if (error) {
    console.error('Error sending message:', error);
    return alert(`Error sending message: ${error.message}`);
  }

  msgInput.value = ''; 
  playNotificationSound();
}

async function loadTeamChatMessages(team) {
    const table = `${team}_chat`; 
    const containerId = `${team}ChatMessages`;

    const { data, error } = await supabase
        .from(table)
        .select('*')
        .order('created_at', { ascending: true }) 
        .limit(50); 

    const messagesContainer = document.getElementById(containerId);
    if (error) {
        console.error(`Error loading ${team} chat messages:`, error);
        messagesContainer.innerHTML = '<div class="message">Error loading chat. Make sure the table exists.</div>';
        return;
    }

    messagesContainer.innerHTML = ''; 
    data.forEach(msg => renderMessage(msg, containerId));
    messagesContainer.scrollTop = messagesContainer.scrollHeight; 
}

async function sendTeamMessage(team) {
    if (!systemConfig.allowChat) {
      alert("Sending messages is currently disabled by the system administrator.");
      return;
    }

    const nameInputId = `${team}ChatNameInput`;
    const msgInputId = `${team}ChatMsgInput`;
    const table = `${team}_chat`; 

    const username = document.getElementById(nameInputId).value.trim();
    const content = document.getElementById(msgInputId).value.trim();

    if (!username) { return alert("Please enter your name."); }
    if (!content) { return alert("Cannot send an empty message."); }

    localStorage.setItem('chat_username', username); 
    document.getElementById('chatNameInput').value = username;
    document.getElementById('blueChatNameInput').value = username;
    document.getElementById('yellowChatNameInput').value = username;

    const { error } = await supabase
        .from(table)
        .insert([{ username, content }]); 

    if (error) {
        console.error(`Error sending ${team} message:`, error);
        return alert(`Error sending message: ${error.message}`);
    }

    document.getElementById(msgInputId).value = ''; 
    playNotificationSound();
}

async function loadSystemHistory(toggle = true) {
  const historyContainer = document.getElementById('systemHistoryContainer');
  const historyList = document.getElementById('historyList');
  
  if (toggle) {
    historyContainer.style.display = historyContainer.style.display === 'block' ? 'none' : 'block';
  }
  
  if (historyContainer.style.display === 'none') return;
  
  historyList.innerHTML = '<li>Loading history...</li>'; 

  const { data, error } = await supabase
    .from('chat_messages')
    .select('content, created_at')
    .like('username', 'System-Alert-%') 
    .order('created_at', { ascending: false })
    .limit(50);

  if (error) {
    console.error('Error loading system history:', error);
    historyList.innerHTML = '<li>Error loading history.</li>';
    return;
  }

  if (data.length === 0) {
    historyList.innerHTML = '<li>No recent join/leave events.</li>';
    return;
  }
  
  historyList.innerHTML = ''; 
  
  data.forEach(item => {
    const date = new Date(item.created_at).toLocaleDateString('en-US');
    const time = new Date(item.created_at).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
    
    let color = '#fff';
    let label = 'Event: ';
    
    // Updated text matching for clear English messages
    if (item.content.includes('joined')) {
        color = '#81c784'; 
        label = '&#9989; Joined: '; 
    } else if (item.content.includes('left')) {
        color = '#ef9a9a'; 
        label = '&#10060; Left: '; 
    } else if (item.content.includes('moved')) { 
        color = '#ffb74d'; 
        label = '&#128337; Moved: '; 
    } else if (item.content.includes('Waiting List because the main team is full')) {
        color = '#ffb74d'; 
        label = '&#128337; Waitlist: ';
    }
    
    let playerName = item.content.replace('Player ', '').replace(' joined the Main Team!', '').replace(' left the Main Team.', '').replace(' moved from Waiting List to Main Team.', '').replace(' was added to the Waiting List because the main team is full.', '').trim(); 

    historyList.innerHTML += `
      <li style="color:${color}; border-bottom: 1px dotted #333; padding-bottom: 5px; margin-bottom: 5px;">
        ${label} <strong>${playerName}</strong>
        <span style="float:right; color:#999; font-size:12px;">${date} at ${time}</span>
      </li>
    `;
  });
}

// =========================================================================================
// ---- 11. REALTIME SETUP & INITIALIZATION ----
// =========================================================================================

function setupRealtime() {
  // Global Chat Updates
  supabase.channel('global-chat-updates')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'chat_messages' },
      (payload) => {
        const storedName = localStorage.getItem('chat_username'); 
        const incomingUsername = payload.new.username.trim();
        if (incomingUsername.startsWith('System-Alert-(')) {
            const historyContainer = document.getElementById('systemHistoryContainer');
            if (historyContainer.style.display === 'block') { loadSystemHistory(false); }
            return; 
        }
        if (storedName && storedName.trim() !== incomingUsername) { playNotificationSound(); }
        renderMessage(payload.new, 'chatMessages'); 
      }
    )
    .subscribe();
    
    // Blue Team Chat Updates
    supabase.channel('blue-chat-updates')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'blue_chat' },
        (payload) => {
            const storedName = localStorage.getItem('chat_username');
            if (storedName && storedName.trim() !== payload.new.username.trim()) { playNotificationSound(); }
            if(document.getElementById('blue').style.display === 'block') { renderMessage(payload.new, 'blueChatMessages'); }
        }
    )
    .subscribe();

    // Yellow Team Chat Updates
    supabase.channel('yellow-chat-updates')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'yellow_chat' },
        (payload) => {
            const storedName = localStorage.getItem('chat_username');
            if (storedName && storedName.trim() !== payload.new.username.trim()) { playNotificationSound(); }
            if(document.getElementById('yellow').style.display === 'block') { renderMessage(payload.new, 'yellowChatMessages'); }
        }
    )
    .subscribe();
    
    // Player List Updates (General Changes)
    supabase.channel('main-team-updates')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'main_team' },
        async (payload) => {
            loadPlayers(); 
        }
    )
    .on('postgres_changes', { event: '*', schema: 'public', table: 'waiting_list' },
        async (payload) => { loadPlayers(); }
    )
    .on('postgres_changes', { event: '*', schema: 'public', table: 'blue_team' },
        async (payload) => { loadBlue(); }
    )
    .on('postgres_changes', { event: '*', schema: 'public', table: 'yellow_team' },
        async (payload) => { loadYellow(); }
    )
    // System Config Updates (NEW)
    .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'app_config', filter: 'id=eq.1' },
        async (payload) => {
            if (payload.new.system_config) {
                const loadedConfig = JSON.parse(payload.new.system_config);
                systemConfig = { ...systemConfig, ...loadedConfig }; 
                applyUIRestrictions();
            }
        }
    )
    .subscribe();
}

// Initial setup after all functions are defined
(async function init() {
    const storedUsername = localStorage.getItem('chat_username');
    if (storedUsername) {
      document.getElementById('chatNameInput').value = storedUsername;
      document.getElementById('blueChatNameInput').value = storedUsername;
      document.getElementById('yellowChatNameInput').value = storedUsername;
    }

    // Event listeners for sending messages via Enter key
    document.getElementById('chatMsgInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') { sendMessage(); }
    });
    document.getElementById('blueChatMsgInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') { sendTeamMessage('blue'); }
    });
    document.getElementById('yellowChatMsgInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') { sendTeamMessage('yellow'); }
    });

    // Initial data loading and setup
    await loadSystemConfig(); // Load config first
    await checkAndClearData(); // Check and clear (will call loadPlayers/Teams/etc.)
    
    // If not called by checkAndClearData:
    if (new Date().getDay() !== 0 || new Date().getHours() < 18) {
        loadPlayers(); 
        loadBlue(); 
        loadYellow(); 
        loadChatMessages();
        loadMatchAddress(); 
    }
    
    setupAddressEditor(); // Setup address editor with the restriction logic
    setupRealtime();
})();
</script>
</body>
</html>
